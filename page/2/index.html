<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="一派胡言">
<meta property="og:url" content="http://threezj.com/page/2/index.html">
<meta property="og:site_name" content="一派胡言">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一派胡言">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://threezj.com/page/2/"/>

  <title> 一派胡言 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">一派胡言</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            Über
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/24/推荐一门CMU公开课/" itemprop="url">
                  Unbenannt
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-24T00:04:52+08:00" content="2016-06-24">
              2016-06-24
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>推荐一门非常有意思的公开课。<code>CMU 15213</code> 由大名鼎鼎的<code>CSAPP</code>的作者主讲。内容就是按照<code>CSAPP</code>这本书为主线进行讲解的，看不进书的同学，强烈建议直接看视频。</p>
<p>这门课最核心的内容是七个<code>lab</code>，非常非常有意思。比如第一个<code>datalab</code>，要求你只允许用<code>! ~ | &amp;amp; +</code>这些位级操作符来进行运算，很头脑风暴，可能有些人写了这么多年代码1个字节几个二进制位都不知道。</p>
<p>我刚刚做完第二个<code>boomlab</code>，通过利用<code>GDB</code>反汇编二进制文件，调试单步执行找到炸弹，要求你可以不会写汇编，但要能看懂汇编。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9C%9620160415204556.jpg" alt=""></p>
<p>最后有个实验貌似是自己实现一个malloc有兴趣的同学可以和我一起跟课。</p>
<ul>
<li><a href="http://www.cs.cmu.edu/~213/index.html" target="_blank" rel="external">CMU 15213</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/24/最小生成树,Prim和Kruskal详细学习笔记/" itemprop="url">
                  Unbenannt
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-24T00:04:52+08:00" content="2016-06-24">
              2016-06-24
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>最小生成树是一副连通加权无向图中一棵权值最小的生成树。<br>最小生成树其实是<strong>最小权重生成树</strong>的简称。</p>
</blockquote>
<p>可能翻译为<code>最小权重生成树</code>更容易理解一些。意思就是说在图中的每条边都加上权值，所谓权值是一种抽象的含义。可以指代一切可以量化的东西。比如说修路的费用，路程等等。然后在图中找到这样一棵树，边的权值加起来最小。并且既然是棵树，必须满足的要求是无环.</p>
<p>一般用两种贪心算法来找到最小生成树，分别是<code>prim</code>和<code>Kruskal</code><br><a id="more"></a></p>
<h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a><code>Kruskal</code></h2><p><code>Kruskal</code> 算法，我觉得比较容易理解，实现也比较简单。</p>
<ol>
<li>新建图G</li>
<li>把图G中所有的边按照权值从小到大排序。(一般使用优先队列)</li>
<li>取出最小的边</li>
<li>如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中.(使用并查集)</li>
<li>重复3，直至图G中所有的节点都在同一个连通分量中</li>
</ol>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalMST</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Edge&gt; mst = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KruskalMST</span><span class="params">(EdgeWeightedGraph g)</span></span>&#123;</span><br><span class="line">        MinPQ&lt;Edge&gt; minPQ = <span class="keyword">new</span> MinPQ&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Edge edge:g.edges())&#123;</span><br><span class="line">            minPQ.insert(edge);</span><br><span class="line">        &#125;</span><br><span class="line">        UF uf =<span class="keyword">new</span> UF(minPQ.size());</span><br><span class="line">        <span class="keyword">while</span> (!minPQ.isEmpty())&#123;</span><br><span class="line">            Edge edge = minPQ.delMin();</span><br><span class="line">            <span class="keyword">int</span> v = edge.either();</span><br><span class="line">            <span class="keyword">int</span> w = edge.other(v);</span><br><span class="line">            <span class="keyword">if</span>(!uf.connected(v,w))&#123;</span><br><span class="line">                uf.union(v,w);</span><br><span class="line">                mst.enqueue(edge);</span><br><span class="line">                <span class="comment">//weight+=edge.weight();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p><code>Kruskal</code> 算法 基本上取决于优先队列的选择，以及并查集的实现。</p>
<p>比较优的算法效率为<code>O(ElogE)</code>E为图中的边数.</p>
<p>对优先队列和并查集不了解的同学可以看看我这两篇文章，<a href="http://threezj.com/2016/03/20/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E9%A1%BA%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91/" target="_blank" rel="external">查找算法之顺序、二分、二叉搜索树、红黑树</a> 和 <a href="http://threezj.com/2016/03/12/Union-Find%20/" target="_blank" rel="external">并查集</a></p>
<h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><p><code>Prim</code>算法，简单的说就是<code>从一个点开始不断让树长大的过程,并且保持权值最小</code>。</p>
<ol>
<li>生成图G</li>
<li>从s点开始</li>
<li>把与s点相连的边都加入<code>edgeTo[]</code>,并且保存到这些点的距离<code>distTo[]</code>,且插入到优先队列</li>
<li>出队一个点</li>
<li>查找与这个点相连的点，若权值比<code>distTo[]</code>中保存的值小则进更新，同时更新<code>distTo[]</code>和优先队列.</li>
<li>重复4</li>
</ol>
<p>如下图</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9C%9620160424222602.jpg" alt=""></p>
<h3 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Edge[] edgeTo;        <span class="comment">// edgeTo[v] = shortest edge from tree vertex to non-tree vertex</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span>[] distTo;      <span class="comment">// distTo[v] = weight of shortest such edge</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;     <span class="comment">// marked[v] = true if v on tree, false otherwise</span></span><br><span class="line"><span class="keyword">private</span> IndexMinPQ&lt;Double&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrimMST</span><span class="params">(EdgeWeightedGraph G)</span></span>&#123;</span><br><span class="line">    edgeTo = <span class="keyword">new</span> Edge[G.V()];</span><br><span class="line">    distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.V()];</span><br><span class="line">    marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">    pq = <span class="keyword">new</span> IndexMinPQ&lt;Double&gt;(G.V());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">        distTo[v] = Double.POSITIVE_INFINITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)      <span class="comment">// run from each vertex to find</span></span><br><span class="line">        <span class="keyword">if</span> (!marked[v]) prim(G, v);      <span class="comment">// minimum spanning forest</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(EdgeWeightedGraph g, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    distTo[s]=<span class="number">0</span>;</span><br><span class="line">    pq.insert(s,distTo[s]);</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">        grow(g,pq.delMin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(EdgeWeightedGraph g, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    marked[v]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (Edge e :g.adj(v))&#123;</span><br><span class="line">        <span class="keyword">int</span> w = e.other(v);</span><br><span class="line">        <span class="keyword">if</span>(marked[w])   <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(distTo[w]&gt;e.weight())&#123;</span><br><span class="line">            distTo[w]=e.weight();</span><br><span class="line">            edgeTo[w] = e;</span><br><span class="line">            <span class="keyword">if</span>(pq.contains(w))</span><br><span class="line">                pq.decreaseKey(w,distTo[w]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pq.insert(w,distTo[w]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>具体性能也是取决于优先队列的选择，一般来说可以达到<code>O(ElogV)</code></p>
<h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><blockquote>
<p>Kruskal can have better performance if the edges can be sorted in linear time, or are already sorted.</p>
<p>Prim’s better if the number of edges to vertices is high.</p>
</blockquote>
<p>引用自<code>stackoverflow</code></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><code>维基百科</code></p>
<p><code>算法4th</code></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/24/最短路径算法总结/" itemprop="url">
                  Unbenannt
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-24T00:04:52+08:00" content="2016-06-24">
              2016-06-24
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为我在跟<code>Robert Sedgewick</code>的<code>Algorithms</code>，所以本文和前面几篇算法文章一样，都是基于这门课的梳理总结，并加以自己理解，这种学习方式其实效率还挺高的。</p>
<h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><p>最短路径问题有多种情况可以讨论</p>
<ul>
<li>给定起点的最短路径问题</li>
<li>给定终点的最短路径问题</li>
<li>给定起点和终点的最短路径，也就是求任意两点之间的最短路径问题</li>
</ul>
<p>本文只讨论<code>单源起点问题</code>，有如下三个算法可以解决这个问题。</p>
<ul>
<li><code>Dijkstra</code>            //适用于无负权重</li>
<li><code>Topological sort</code>    //适用于无环</li>
<li><code>Bellman-Ford</code>        //适用于无负环<a id="more"></a></li>
</ul>
<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><blockquote>
<p>对于不含负权的有向图，这是目前已知的最快的单源最短路径算法</p>
</blockquote>
<p>比较有意思的是，这个算法可以说就是<code>prim</code>算法。只不过就是比较的依据从<code>相对于整棵树</code>变成了<code>源点</code></p>
<p>所以，原理依旧是贪心算法，保证每一步都是最短。这里需要用优先队列来保存边。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>初始化所有顶点到源点的路径为无限大</li>
<li>顶点插入优先队列</li>
<li>出队一个点</li>
<li>对所有与这个点相关联的边进行<code>放松</code>操作</li>
<li>重复3</li>
</ol>
<p>所谓的<code>放松</code>操作，就是一个比较的过程，若比原来的距离更短即进队。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>可以看到下面的代码基本上和<code>Prim</code>一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @author Robert Sedgewick @author Kevin Wayne</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DijkstraSP</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (DirectedEdge e : G.edges()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (e.weight() &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"edge "</span> + e + <span class="string">" has negative weight"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.V()];</span><br><span class="line">       edgeTo = <span class="keyword">new</span> DirectedEdge[G.V()];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">           distTo[v] = Double.POSITIVE_INFINITY;</span><br><span class="line">       distTo[s] = <span class="number">0.0</span>;</span><br><span class="line">       <span class="comment">// relax vertices in order of distance from s</span></span><br><span class="line">       pq = <span class="keyword">new</span> IndexMinPQ&lt;Double&gt;(G.V());</span><br><span class="line">       pq.insert(s, distTo[s]);</span><br><span class="line">       <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">int</span> v = pq.delMin();</span><br><span class="line">           <span class="keyword">for</span> (DirectedEdge e : G.adj(v))</span><br><span class="line">               relax(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// relax edge e and update pq if changed</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(DirectedEdge e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> v = e.from(), w = e.to();</span><br><span class="line">       <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + e.weight()) &#123;</span><br><span class="line">           distTo[w] = distTo[v] + e.weight();</span><br><span class="line">           edgeTo[w] = e;</span><br><span class="line">           <span class="keyword">if</span> (pq.contains(w)) pq.decreaseKey(w, distTo[w]);</span><br><span class="line">           <span class="keyword">else</span>                pq.insert(w, distTo[w]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于Dijkstra为什么不能含有负权值"><a href="#关于Dijkstra为什么不能含有负权值" class="headerlink" title="关于Dijkstra为什么不能含有负权值"></a>关于<code>Dijkstra</code>为什么不能含有负权值</h3><p>可以想象一下，如果有一条负边在图中。<code>Dijkstra</code>维护的优先队列，每次都是取一条最小的边出来的，而这条负边，可以使这条路无限小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(DirectedEdge e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> v = e.from(), w = e.to();</span><br><span class="line">       <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + e.weight()) &#123;   <span class="comment">//若是负边的话每次都会减小，就会不断进入优先队列！！！</span></span><br><span class="line">           distTo[w] = distTo[v] + e.weight();  </span><br><span class="line">           edgeTo[w] = e;</span><br><span class="line">           <span class="keyword">if</span> (pq.contains(w)) pq.decreaseKey(w, distTo[w]);</span><br><span class="line">           <span class="keyword">else</span>                pq.insert(w, distTo[w]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p><code>Dijkstra</code>效率取决于优先队列的效率。二叉堆的话效率为<code>O(ElogV)</code></p>
<h2 id="Topological-sort"><a href="#Topological-sort" class="headerlink" title="Topological sort"></a>Topological sort</h2><p>这种方法实现简单，效率也高，但只适用于无环图，权值可以为负。</p>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>初始化所有顶点到源点的路径为无限大</li>
<li>对顶点进行<code>拓扑排序</code></li>
<li>按照顶点顺序，对每条相关的边进行<code>放松</code></li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Topological topological = <span class="keyword">new</span> Topological(G);</span><br><span class="line"><span class="keyword">if</span> (!topological.hasOrder())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Digraph is not acyclic."</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : topological.order()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (DirectedEdge e : G.adj(v))</span><br><span class="line">        relax(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="效率-1"><a href="#效率-1" class="headerlink" title="效率"></a>效率</h3><blockquote>
<p>Topological sort algorithm computes SPT in any edgeweighted<br>DAG in time proportional to E + V</p>
</blockquote>
<h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h2><p>对于无负环的图一种解决方案。最直接的实现是对所有边进行<code>V-1</code>次放松,但是效率太低。复杂度高达<code>O(V*E)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e : G.adj(v))</span><br><span class="line">            relax(e);</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>原始的版本总共进行<code>V-1</code>次放松，但其实，后面的很多次都是无效的放松，实际中不到<code>V-1</code>次就已经放松完全了。判断依据就是<code>distTo[v]</code>有无变化。</p>
<p>这种方法时间复杂度最坏情况依旧是<code>O(V*E)</code>，平均情况已经快很多了<code>O(E+V)</code></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>算法4th</p>
<p>维基百科</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/24/查找算法之顺序、二分、二叉搜索树、红黑树 详细比较总结/" itemprop="url">
                  Unbenannt
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-24T00:04:52+08:00" content="2016-06-24">
              2016-06-24
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般用<code>符号表</code>来储存键值对，就好像字典那样，通过索引来查找值，若键重复则覆盖值。我们能希望找到一种高效的查找算法使在平均情况和最差情况下，时间复杂度都能达到<code>O(logn)</code>。下面会逐步介绍四种算法，最终达到我们的目的。</p>
<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>用链表实现，无法索引数据，必须遍历找数据，速度比较慢，查找插入时间复杂度都为<code>O(n)</code>，而且无法保证有序。但是实现简单，适用于小型数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearchST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value v)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.key.equals(key))&#123;</span><br><span class="line">                p.v=v;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head=<span class="keyword">new</span> Node(key,v,head);</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        Node p=head;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.key.equals(key))&#123;</span><br><span class="line">                <span class="keyword">return</span>  p.v;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>用数组保存数据，保证有序。二分查找速度很快，但是仅限于查找。因为插入的时候要保证有序，所以要往后移动数据以便插入。查找复杂度<code>O(logn)</code>,插入复杂度<code>O(n)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>,<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index=rank(key);</span><br><span class="line">        <span class="comment">//键相等则覆盖值</span></span><br><span class="line">        <span class="keyword">if</span>(keys[index]!=<span class="keyword">null</span>&amp;&amp;key.compareTo(keys[index])==<span class="number">0</span>)&#123; </span><br><span class="line">            values[index]=value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把数据往后移，以便插入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=size+<span class="number">1</span>;i&gt;index;i--)&#123;</span><br><span class="line">            keys[i]=keys[i-<span class="number">1</span>];</span><br><span class="line">            values[i]=values[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        keys[index]=key;</span><br><span class="line">        values[index]=value;</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index=rank(key);<span class="comment">//二分查找</span></span><br><span class="line">        <span class="keyword">if</span>(keys[index]!=<span class="keyword">null</span> &amp;&amp; key.compareTo(keys[index])==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> values[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;<span class="keyword">return</span> rank(key,<span class="number">0</span>,size);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key,<span class="keyword">int</span> l,<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;h) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+h)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(keys[mid]!=<span class="keyword">null</span>)</span><br><span class="line">            cmp=key.compareTo(keys[mid]);</span><br><span class="line">        <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> rank(key,l,mid-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> rank(key,mid+<span class="number">1</span>,h);</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a><code>二叉搜索树</code></h2><p>通过前面两个算法，我们可以知道链表能快速删除插入，而二分能快速查找。所以我们想找到一种结构既是链式结构，同时又能进行二分查找，同时保证查找和插入的高效性。</p>
<p>答案就是<code>二叉搜索树</code>。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>是二叉树</li>
<li>每个节点含有一个键和关联的值</li>
<li>每个节点大于左子树上所有结点的值且小于右子树上所有节点的值</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>其实给出定义，实现就已经很清楚了。说白了就是从无到有构造一个二叉树，每次插入都和树中的节点进行比较，小的放左边，大的放右边。就如同<code>快速排序</code>，用一个主元把左右两边分开。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320221749.jpg" alt=""></p>
<p>还是直接看代码清楚点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">put</span><span class="params">(Node x, Key key, Value value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>) x.left=put(x.left,key,value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>) x.right=put(x.right,key,value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            x.value=value;</span><br><span class="line">            x.N = size(x.right)+size(x.left)+<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp =key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)   <span class="keyword">return</span> get(x.left,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>) <span class="keyword">return</span> get(x.right,key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p><code>二叉搜索树</code>的查找和搜索在平均情况下时间复杂度都能达到<code>O(logn)</code>，而且能保证数据有序。<code>二叉搜索树</code>的中序遍历就是数据的顺序。我们貌似已经找到了一个最理想的算法。</p>
<p>但是这个效率只是在平均情况下。如果数据是逆序，或者顺序，那么这棵树就会发生一边倒的情况使复杂度直接达到<code>O(n)</code>，就如同快排中选择到糟糕的主元(最大或者最小)。比快排糟糕的是，<code>快排</code>我们能通过随机打乱数据来避免这种情况发生。但<code>二叉搜索树</code>则不行，数据都是客户提供，直接插入到树中的，这种情况其实经常发生。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320222706.jpg" alt=""></p>
<p>幸运的是我们有<code>平衡二叉树</code>可以解决这个问题。</p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><code>平衡二叉树</code></h2><h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a><code>2-3树</code></h3><p>为了保持树平衡性，允许节点能保存两个键值对，且能连三个儿子。这样把节点分成了两种类型。</p>
<ul>
<li><code>2-节点</code> : 一个键值对，两个儿子。 (也就是标准的<code>二叉搜索树</code>)</li>
<li><code>3-节点</code> : 两个键值对，三个儿子。 (两个键是有序的，左小右大。左儿子小于左边的键，右儿子大于右边的键，中间的儿子在两个键之间)</li>
</ul>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320225636.jpg" alt=""></p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><code>2-3树</code>插入比较复杂。在插入的同时保持平衡性。</p>
<ul>
<li>向<code>2-节点</code>中插入键。这种情况比较简单。直接插入即可。</li>
<li>向<code>3-节点</code>中插入键。比较特殊。先暂时把键插入到<code>3-节点</code>，此时这个节点中就有了三个键，然后再把这个节点分开。把中间的儿子简单当根，左右两边的键当儿子。若父节点还是<code>3-节点</code>，则继续递归进行。</li>
</ul>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/search2-3_insertion.svg.png" alt=""></p>
<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p><code>2-3树</code>性能可以说是比较好的。不管数据怎么样，查找删除操作时间复杂度都能达到O(logn)。<br>但是<code>2-3树</code>实现比较复杂，需要掌控的情况很多，剥离节点，传递节点等操作，都需要很复杂的代码，且也会耗费不少的时间。所以我们一般不怎么用原始的<code>2-3树</code>，而是用<code>2-3树</code>的变形<code>红黑树</code>.</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a><code>红黑树</code></h3><p><code>红黑树</code>最方便的地方除了插入和删除操作的代码略复杂以外，另外的操作都可以直接复制<code>二叉搜索树</code>。</p>
<p><code>红黑树</code>是<code>2-3树</code>的变形，把<code>3-节点</code>分离开来使之成为普通的<code>2-节点</code>。但是怎么表现分离开的节点之间的联系呢。我们用红线把他们连起来。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320231811.jpg" alt=""></p>
<p>巧妙地结合<code>二叉搜索树</code>的高效查找操作和<code>2-3树</code>的平衡插入操作。</p>
<p>每个节点都只有一根连向父节点的线。这个线的颜色称为节点的颜色。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>我们通过旋转来维持树的平衡。一般有两种情况需要旋转。</p>
<ul>
<li>连续两个左节点的颜色为红色,向右转</li>
<li>右节点的颜色为红色，向左转</li>
<li>第三种情况是左右两边都为红色。最好处理，不需要旋转。只需要把左右两个儿子的颜色改成黑色，再把自己的颜色改成黑色。可以想象成把3个键值对<code>3-节点</code>剥离开。</li>
</ul>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320232738.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackRedBST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>,<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, Key key, Value value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value,<span class="number">0</span>,RED);</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>) x.left = put(x.left,key,value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>) x.right = put(x.right,key,value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp==<span class="number">0</span>) x.value =value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( isRED(x.right) &amp;&amp; !isRED(x.left)) x=rotateLeft(x);</span><br><span class="line">        <span class="keyword">if</span>( isRED(x.left) &amp;&amp; isRED(x.left.left)) x=rotateRight(x);</span><br><span class="line">        <span class="keyword">if</span>( isRED(x.left) &amp;&amp; isRED(x.right)) flipColor(x);</span><br><span class="line">        x.N = size(x.right) + size(x.left) +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>  x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColor</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        x.right.color = BLACK;</span><br><span class="line">        x.left.color = BLACK;</span><br><span class="line">        x.color = RED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotateLeft</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        Node r =x.right;</span><br><span class="line">        x.right = r.left;</span><br><span class="line">        r.left = x;</span><br><span class="line">        r.color = x.color;</span><br><span class="line">        x.color = RED;</span><br><span class="line">        x.N = size(x.left)+size(x.right) +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotateRight</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        Node r =x.left;</span><br><span class="line">        x.left = r.right;</span><br><span class="line">        r.right = x;</span><br><span class="line">        r.left.color = RED;</span><br><span class="line">        r.right.color = RED;</span><br><span class="line">        r.color =BLACK;</span><br><span class="line">        x.N = size(x.left)+size(x.right) +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><p>无论数据如何，插入删除时间复杂度都为<code>O(logn)</code>，可以说达到了理想状态，且代码简单。</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>分别对四个文件进行插入搜索操作。</p>
<ul>
<li><code>tale.txt</code>(779kb)<br>顺序查找(7.143秒) 二分查找(0.46秒) <code>二叉搜索树</code>(0.191秒) <code>红黑树</code>(0.237秒)</li>
<li><code>leipzig100k.txt</code>(12670kb)<br>顺序查找(无) 二分查找(13.911秒) <code>二叉搜索树</code>(1.389秒) <code>红黑树</code>(1.442秒)</li>
<li><code>leipzig300k.txt</code>(37966kb)<br>顺序查找(无) 二分查找(60.222秒) <code>二叉搜索树</code>(2.742秒) <code>红黑树</code>(3.104秒)</li>
<li><code>leipzig1m.txt</code>(126607kb)<br>顺序查找(无) 二分查找(无) <code>二叉搜索树</code>(3.016秒) <code>红黑树</code>(2.797秒)</li>
</ul>
<p>由上面的数据分析，顺序查找实际是非常慢的。而二分查找对小型数据还是比较快，但是数据一大就不行了。</p>
<p>而这里的<code>二叉搜索树</code>和<code>红黑树</code>，无论什么数据效率都是极高。而且由<code>leipzig300k.txt</code>到<code>leipzig1m.txt</code>数据几乎翻了4倍，而这两种算法的效率几乎没收什么影响。</p>
<p>这里因为我的数据比较平均的关系，比较不出红黑树和二叉搜索树的差异。我自己构造了一组数据进行测试。完全逆序的<code>100000</code>个数进行插入删除。</p>
<ul>
<li>红黑树(0.173秒)</li>
<li>二叉搜索树(StackOverflow)</li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320233331.jpg" alt=""></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>维基百科</p>
<p><a href="http://www.amazon.cn/%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6-%E7%AE%97%E6%B3%95-%E5%A1%9E%E5%A5%87%E5%A8%81%E5%85%8B/dp/B009OCFQ0O/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1457882078&amp;sr=1-1&amp;keywords=%E7%AE%97%E6%B3%95" target="_blank" rel="external">算法 4th</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/24/用拉链法和线性探测法解决哈希冲突/" itemprop="url">
                  Unbenannt
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-24T00:04:52+08:00" content="2016-06-24">
              2016-06-24
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面学习到的几种算法比如<code>红黑树</code>，<code>二叉搜索树</code>，查找插入<code>时间复杂度</code>最快也只能到<code>O(logn)</code>.现在介绍一种算法可以使查找插入<code>时间复杂度</code>达到常数级别。</p>
<h2 id="散列表-Hash-table"><a href="#散列表-Hash-table" class="headerlink" title="散列表(Hash table)"></a>散列表(Hash table)</h2><p>也称为<code>哈希表</code>。是字典的一种抽象。比如说你要查一个字，通过这个字的拼音首字母，找到这个字的页码，然后翻到那页找就行了。这种方法直接把查找<code>时间复杂度</code>降到了常数。但是要牺牲一定的计算索引的时间。计算索引的那个函数称为<code>哈希函数</code>(<code>散列函数``)。如果两个不同的</code>key`算出了同一个索引，此时就要用到一定的方法来解决哈希冲突。<br><a id="more"></a></p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p><code>哈希函数</code>一般具有如下特点。</p>
<ul>
<li>相等的<code>key</code>产生相等的<code>哈希值</code></li>
<li>计算简单方便</li>
<li><code>哈希值</code>均匀分布。(若过度集中，则容易使效率降低到<code>o(n)</code>)</li>
</ul>
<p>构造<code>哈希函数</code>有多种方法，这里不详细讲解。</p>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>若两个不相等的<code>key</code>产生了相等的<code>哈希值</code>，这时则需要采用<code>哈希冲突</code>。</p>
<h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p><code>Java</code>标准库的<code>HashMap</code>基本上就是用<code>拉链法</code>实现的。<code>拉链法</code>的实现比较简单，将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160328161219.jpg" alt=""></p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ul>
<li>得到一个<code>key</code></li>
<li>计算<code>key</code>的<code>hashValue</code></li>
<li>根据<code>hashValue</code>值定位到<code>data[hashValue]</code>。(<code>data[hashValue]</code>是一条链表)</li>
<li>若<code>data[hashValue]</code>为空则直接插入</li>
<li>不然则添加到表头</li>
</ul>
<p>这里需要注意的是，<code>哈希函数</code>必须保证<code>哈希值</code>的<code>均匀分布</code>，若全部集中在一条链表中，则<code>时间复杂度</code>和顺序链表相同。</p>
<p>还有一点则是数组的大小，若你能估计数据的大小，则直接指定即可，否则就需要<code>动态扩充</code>数组。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparateChainingHashST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//这里的M需要根据实际情况调整</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">(<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.M = M;</span><br><span class="line">            st = (SequentialSearchST&lt;Key, Value&gt;[]) <span class="keyword">new</span> SequentialSearchST[M];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">                st[i]=<span class="keyword">new</span> SequentialSearchST&lt;Key,Value&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key k,Value v)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hashValue = hash(k);</span><br><span class="line">            st[hashValue].put(k,v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key k)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hashValue = hash(k);</span><br><span class="line">            <span class="keyword">return</span> st[hashValue].get(k);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h3><p><code>线性探测</code>直接使用数组来存储数据。可以想象成一个停车问题。若当前车位已经有车，则你就继续往前开，直到找到下一个为空的车位。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160328162810.jpg" alt=""></p>
<h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><ul>
<li>得到<code>key</code></li>
<li>计算得<code>hashValue</code></li>
<li>若不冲突，则直接填入数组</li>
<li>若冲突，则使<code>hashValue++</code>，也就是往后找，直到找到第一个<code>data[hashValue]</code>为空的情况,则填入。若到了尾部可循环到前面。</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Object[cap];</span><br><span class="line">        values = (Value[]) <span class="keyword">new</span> Object[cap];</span><br><span class="line">        M = cap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//若当前数据含量超过了总容量的一半，则重新调整容量</span></span><br><span class="line">        <span class="keyword">if</span>(N&gt;=M/<span class="number">2</span>) resize(<span class="number">2</span>*M);  </span><br><span class="line">        <span class="keyword">int</span> hashValue = hash(key);</span><br><span class="line">        <span class="keyword">if</span> (values[hashValue]==<span class="keyword">null</span>)&#123;</span><br><span class="line">            keys[hashValue] = key;</span><br><span class="line">            values[hashValue] = value;</span><br><span class="line">            N++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(keys[hashValue].equals(key))&#123;</span><br><span class="line">            values[hashValue]=value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (values[hashValue] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                hashValue = (hashValue+<span class="number">1</span>)%M;</span><br><span class="line">            &#125;</span><br><span class="line">            keys[hashValue] = key;</span><br><span class="line">            values[hashValue] = value;</span><br><span class="line">            N++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashValue = hash(key);</span><br><span class="line">        <span class="keyword">if</span> (keys[hashValue]!=<span class="keyword">null</span>&amp;&amp;!keys[hashValue].equals(key))&#123;</span><br><span class="line">            <span class="keyword">while</span> (keys[hashValue]!=<span class="keyword">null</span> &amp;&amp;keys[hashValue]!=key)&#123;</span><br><span class="line">                hashValue = (hashValue+<span class="number">1</span>)%M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values[hashValue];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>一般来说，使用<code>散列表</code>会比<code>红黑树</code>快很多。但具体还是要看<code>哈希函数</code>的计算效率。但是<code>散列表</code>无法保证顺序，所以如果你需要进行有关顺序的操作，应该使用<code>红黑树</code>或者<code>二叉搜索树</code>。</p>
<p>对于<code>线性探测</code>来说动态调整数组大小是必要的，不然会产生死循环。</p>
<p><code>拉链法</code>的删除操作比较方便，直接链表修改地址即可。而<code>线性探测</code>删除操作很复杂，而且<code>线性探测</code>耗费的内存比拉链法要多。</p>
<p>分别对四个文件进行插入搜索操作。</p>
<ul>
<li><code>tale.txt</code>(779kb)<br>顺序查找(7.143秒) 二分查找(0.46秒) <code>二叉搜索树</code>(0.191秒) <code>红黑树</code>(0.237秒) <code>拉链法</code>(0.124秒) <code>线性探测</code>(0.103秒)</li>
<li><code>leipzig100k.txt</code>(12670kb)<br>顺序查找(无) 二分查找(13.911秒) <code>二叉搜索树</code>(1.389秒) <code>红黑树</code>(1.442秒)<br><code>拉链法</code>(0.707秒) <code>线性探测</code>(0.562秒)</li>
<li><code>leipzig300k.txt</code>(37966kb)<br>顺序查找(无) 二分查找(60.222秒) <code>二叉搜索树</code>(2.742秒) <code>红黑树</code>(3.104秒)<br><code>拉链法</code>(1.839秒) <code>线性探测</code>(1.559秒)</li>
<li><code>leipzig1m.txt</code>(126607kb)<br>顺序查找(无) 二分查找(无) <code>二叉搜索树</code>(3.016秒) <code>红黑树</code>(2.797秒)<br><code>拉链法</code>(3.938秒) <code>线性探测</code>(3.668秒)</li>
</ul>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160328190932.jpg" alt=""></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><code>维基百科</code></p>
<p><a href="http://www.amazon.cn/%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6-%E7%AE%97%E6%B3%95-%E5%A1%9E%E5%A5%87%E5%A8%81%E5%85%8B/dp/B009OCFQ0O/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1457882078&amp;sr=1-1&amp;keywords=%E7%AE%97%E6%B3%95" target="_blank" rel="external">算法 4th</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/24/简单排序之冒泡、选择、插入、希尔详细总结/" itemprop="url">
                  Unbenannt
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-24T00:04:52+08:00" content="2016-06-24">
              2016-06-24
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文讲述一些简单算法的实现和效率比较。所有代码用<code>java</code>实现。用到的两个基本的<code>api</code>代码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v,Comparable w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w) &lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    Comparable temp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h2><p>一般算法入门，都是用冒泡做的例子。但实际中基本很难用到，复杂度<code>O(n²)</code>。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>一趟一趟的比，每一趟中，循环剩余的数，和后一个进行比较，若比它小则交换。这样一趟下来最小的在第一个，最大的在最后一个。总共比<code>n-1</code>趟。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Bubblesort implements Sortable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sort(Comparable[] a) &#123;</span><br><span class="line">        for(int i=0;i&lt;a.length-1;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;a.length-1-i;j++)&#123;</span><br><span class="line">                if(less(a[j+1],a[j]))&#123;</span><br><span class="line">                    exch(a,j,j+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>上面的算法，无论的你的数据怎么样，始终都要比<code>n²</code>次，效率很低。若你的数据局部有序，经过几趟交换以后，已经有序，则不用继续往下比。效率会高很多。优化代码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubblesort</span> <span class="keyword">implements</span> <span class="title">Sortable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> didSwap = flase;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(less(a[j+<span class="number">1</span>],a[j]))&#123;</span><br><span class="line">                    exch(a,j,j+<span class="number">1</span>);</span><br><span class="line">                    didSwap = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!didSwap) <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="选择排序-Selection-sort"><a href="#选择排序-Selection-sort" class="headerlink" title="选择排序(Selection sort)"></a>选择排序(Selection sort)</h2><p>和冒泡复杂度一样<code>O(n²)</code>，但是时间上可能会比冒泡稍微快一点，因为交换的次数比冒泡少。</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>选择排序可以说是最好理解的算法。就是每次遍历一趟，找出最小的数，放到最前端。（这里说的是最前，是指无序的队列中的最前）</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> <span class="keyword">implements</span> <span class="title">Sortable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;a.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(less(a[j],a[min]))&#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(a,i,min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>时间复杂度O(n²)。</p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>遍历未排序序列。把未排序数列的第一个数和已排序数列的每一个数比较，若比它大则交换。经典的理解方式就是理解成摸牌时候理牌的顺序。我上面的实现是直接交互数字，若是把大的数直接往后移效率还会更高。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/sortQQ%E6%88%AA%E5%9C%9620160313220945.jpg" alt=""></p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> <span class="keyword">implements</span> <span class="title">Sortable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(less(a[j],a[j-<span class="number">1</span>]))&#123;</span><br><span class="line">                    exch(a,j,j-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="适合插入排序的数据"><a href="#适合插入排序的数据" class="headerlink" title="适合插入排序的数据"></a>适合插入排序的数据</h3><p>当你的数据是基本有序的时候且数据量小，利用插入排序的时候，效率会很高。若数据为逆序的话，效率很低。</p>
<h2 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序(Shell Sort)"></a>希尔排序(Shell Sort)</h2><p>可以看出是插入排序的一种优化，或者是预处理。希尔排序就是先进行<code>h-sort</code>，也就是让间隔为<code>h</code>的元素都是有序的。普通的插入排序就是<code>1-sort</code>。</p>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>主要就是选定一个h的有序数组来进行预排序。这样最后进行插入排序的时候，能使数据局部有序。就算交换的话，交换的次数也不会很多。这样h序列称为<code>递增序列</code>。希尔的性能很大部分取决于<code>递增序列</code>.一般来说我们使用这个序列<code>3x + 1</code>.</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/sortQQ%E6%88%AA%E5%9C%9620160313224750.jpg" alt=""></p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> <span class="keyword">implements</span> <span class="title">Sortable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h&lt;a.length/<span class="number">3</span>)&#123;</span><br><span class="line">            h=<span class="number">3</span>*h+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;a.length;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=h;j=j-h)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(less(a[j],a[j-h]))&#123;</span><br><span class="line">                        exch(a,j,j-h);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h=h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>对于希尔排序的性能其实无法准确表示。介于<code>O(nlogn)</code>和<code>O(n²)</code>之间，大概在n的1.5次幂左右。</p>
<p>希尔排序对于中大型数据的排序效率是很高的，而且占用空间少，代码量短。而且就算是很大的数据，用类似快排这种高性能的排序方法，也仅仅只比希尔快两倍或者不到。</p>
<h2 id="运行时间比较"><a href="#运行时间比较" class="headerlink" title="运行时间比较"></a>运行时间比较</h2><p>我测试了一下,用5000个数据，排序100次。使用上述四个算法的运行时间如下。</p>
<blockquote>
<p>冒泡排序 5.734000000000004</p>
<p>选择排序 2.351</p>
<p>插入排序 2.720999999999999</p>
<p>希尔排序 0.09400000000000007</p>
</blockquote>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.amazon.cn/%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6-%E7%AE%97%E6%B3%95-%E5%A1%9E%E5%A5%87%E5%A8%81%E5%85%8B/dp/B009OCFQ0O/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1457882078&amp;sr=1-1&amp;keywords=%E7%AE%97%E6%B3%95" target="_blank" rel="external">算法 4th</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Threezj" />
          <p class="site-author-name" itemprop="name">Threezj</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Threezj</span>
</div>

<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  
  

  

  

</body>
</html>
