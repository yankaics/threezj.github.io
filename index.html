<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="一派胡言">
<meta property="og:url" content="http://threezj.com/index.html">
<meta property="og:site_name" content="一派胡言">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一派胡言">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://threezj.com/"/>

  <title> 一派胡言 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">一派胡言</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            Über
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/04/CSAPP Cache 详细解析/" itemprop="url">
                  CSAPP Cache 详细解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-05-04T00:13:06+08:00" content="2016-05-04">
              2016-05-04
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>又要来推荐<code>CSAPP</code>这本书啦。很多同学可能写了这么久代码，计算机的基本工作方式都不太懂，看这本书会给你一种融会贯通的感觉，小到二进制位级操作，大到手撸web服务器。</p>
<p>今天主要整理下<code>Cache</code>的运行机制。</p>
<h2 id="什么是Cache"><a href="#什么是Cache" class="headerlink" title="什么是Cache"></a>什么是<code>Cache</code></h2><p>编程说到底其实就是对数据的操作。<code>CPU</code>通过各种总线从读取数据，放入<code>ALU(运算器)</code>进行运算，然后再把数据放回主存中。下面是一个简单的示意图。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9C%9620160503224541.jpg" alt=""></p>
<p>很明显。数据运输过程的时间，就是性能的提现。没有数据<code>CPU</code>只能在那里等待.所以为了加快主存到<code>CPU</code>的速度，系统设计者采取了存储设备分层的结构.</p>
<p><code>Cache</code>又称为<code>高速缓存存储器</code>，是一种非常小非常快的存储器，同时也非常贵，放在<code>CPU</code>和<code>主存</code>之间，相当于中介的存在，每当<code>CPU</code>取数据的时候总是先从<code>Cache</code>中找，如果<code>Cache</code>没有，再到<code>主存</code>找。</p>
<p><code>CPU</code>和<code>主存</code>直接会放置多个<code>Cache</code>，越靠近<code>CPU</code>则越小越快越贵。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9C%9620160503230817.jpg" alt=""></p>
<h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p>程序一般使用数据，都倾向于使用地址靠近的数据，或者是最近刚刚使用过的数据。回想下你之前写的程序是不是这样。比如说数组，一整块连续的地址循环访问。不断访问同一个数据去做求和之类的操作。所以分为如下</p>
<ul>
<li>时间局部性</li>
<li>空间局部性</li>
</ul>
<h2 id="Cache工作原理"><a href="#Cache工作原理" class="headerlink" title="Cache工作原理"></a>Cache工作原理</h2><p>查找<code>Cache</code>中数据时，找到了称为<code>Hit</code>,没找到则称为<code>Miss</code></p>
<h3 id="Cache-Miss-Type"><a href="#Cache-Miss-Type" class="headerlink" title="Cache Miss Type"></a>Cache Miss Type</h3><p><code>Miss</code>的情况分为三种</p>
<ul>
<li><code>Cold Miss</code>.也就是第一次找的时候，<code>Cache</code>不含数据，当然是<code>Miss</code></li>
<li><code>Conflict Miss</code>.比较有意思的一种的情况。比如说第一次查找数据<code>0</code>，第一次时不含数据属于<code>Cold Miss</code>，然后就去主存中找，放到<code>Cache</code>中，第二次查找需要数据<code>8</code>，又没有，继续去主存那里找，注意！，<code>8</code>把放到<code>Cache</code>中时覆盖了<code>0</code>，第三次你又需要<code>0</code>了，然后就悲剧了，不断<code>0,8,0,8,0,8,0,8 Miss</code>,当然这里涉及到一个写策略。</li>
<li><code>Capacity Miss</code>.这种也比较容易理解，就是你需要的数据超过<code>Cache</code>的大小了，当然<code>Miss</code>了</li>
</ul>
<h3 id="Cache-Replacement-Policies-Cache替换策略"><a href="#Cache-Replacement-Policies-Cache替换策略" class="headerlink" title="Cache Replacement Policies(Cache替换策略)"></a>Cache Replacement Policies(Cache替换策略)</h3><ul>
<li><code>Random</code>  随机替换</li>
<li><code>LRU</code>     <code>Least Recently Used</code>，替换最近最少使用的数据</li>
<li><code>FIFO</code>    这个应该很熟悉先进先出法。先保存的数据先出去</li>
</ul>
<h3 id="Cache-查找原理"><a href="#Cache-查找原理" class="headerlink" title="Cache 查找原理"></a>Cache 查找原理</h3><p>了解查找之前先要知道<code>Cache</code>的组成结构，总共分为两块。</p>
<ul>
<li><code>set</code></li>
<li><code>line</code></li>
</ul>
<p>一块Cache，有多个<code>set</code>，一个<code>set</code>有多行<code>line</code>.</p>
<p><code>set</code>个数取决于你是几位的机器，因为查找数据的时候是根据地址来区分是哪个<code>set</code>的。</p>
<p><code>line</code>中又分成三块。</p>
<ul>
<li><code>valid bit</code>  标志位，标志这块数据是否有效</li>
<li><code>tag</code>        相当于身份证，只有部分地址和这个<code>tag</code>对上以后，才能继续访问<code>block</code></li>
<li><code>block</code>      数据真正存放的地方</li>
</ul>
<p>那么地址又是如何划分的呢？也是分成三块</p>
<ul>
<li><code>tag</code>            对应前面’line’的’tag’</li>
<li><code>set index</code>      用来查找属于哪个’set’</li>
<li><code>block offset</code>   块偏移量确定数据的位置</li>
</ul>
<p>我这么讲可能比较抽象，直接看下图，再对照着看上面的文字，应该比较容易理解。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9C%9620160503235056.jpg" alt=""></p>
<p>所以<code>Cache</code>的查找过程是怎么样的呢？</p>
<ol>
<li>根据<code>set index</code>找到属于哪个<code>set</code></li>
<li>查找<code>set</code>中的每一行<code>line</code></li>
<li>先看<code>valid bit</code>是否有效</li>
<li>接着比对<code>tag</code></li>
<li>根据<code>block offset</code>获取数据</li>
</ol>
<h2 id="回写策略"><a href="#回写策略" class="headerlink" title="回写策略"></a>回写策略</h2><p>回写指的是，保持数据一致性，需要写回到主存中，这也很好理解，不回写的话数据就不同步了。</p>
<ul>
<li><code>Write-through</code> 直接把数据写回到主存中</li>
<li><code>Write-back</code>    等知道数据在<code>Cache</code>中要被覆盖了再写回到主存中</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>CSAPP<br>CMU 15213<br>维基百科</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/02/最短路径算法总结/" itemprop="url">
                  最短路径算法总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-05-02T15:13:06+08:00" content="2016-05-02">
              2016-05-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为我在跟<code>Robert Sedgewick</code>的<code>Algorithms</code>，所以本文和前面几篇算法文章一样，都是基于这门课的梳理总结，并加以自己理解，这种学习方式其实效率还挺高的。</p>
<h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><p>最短路径问题有多种情况可以讨论</p>
<ul>
<li>给定起点的最短路径问题</li>
<li>给定终点的最短路径问题</li>
<li>给定起点和终点的最短路径，也就是求任意两点之间的最短路径问题</li>
</ul>
<p>本文只讨论<code>单源起点问题</code>，有如下三个算法可以解决这个问题。</p>
<ul>
<li><code>Dijkstra</code>            //适用于无负权重</li>
<li><code>Topological sort</code>    //适用于无环</li>
<li><code>Bellman-Ford</code>        //适用于无负环<a id="more"></a></li>
</ul>
<h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><blockquote>
<p>对于不含负权的有向图，这是目前已知的最快的单源最短路径算法</p>
</blockquote>
<p>比较有意思的是，这个算法可以说就是<code>prim</code>算法。只不过就是比较的依据从<code>相对于整棵树</code>变成了<code>源点</code></p>
<p>所以，原理依旧是贪心算法，保证每一步都是最短。这里需要用优先队列来保存边。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>初始化所有顶点到源点的路径为无限大</li>
<li>顶点插入优先队列</li>
<li>出队一个点</li>
<li>对所有与这个点相关联的边进行<code>放松</code>操作</li>
<li>重复3</li>
</ol>
<p>所谓的<code>放松</code>操作，就是一个比较的过程，若比原来的距离更短即进队。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>可以看到下面的代码基本上和<code>Prim</code>一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @author Robert Sedgewick @author Kevin Wayne</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DijkstraSP</span><span class="params">(EdgeWeightedDigraph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (DirectedEdge e : G.edges()) &#123;</span><br><span class="line">           <span class="keyword">if</span> (e.weight() &lt; <span class="number">0</span>)</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"edge "</span> + e + <span class="string">" has negative weight"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.V()];</span><br><span class="line">       edgeTo = <span class="keyword">new</span> DirectedEdge[G.V()];</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">           distTo[v] = Double.POSITIVE_INFINITY;</span><br><span class="line">       distTo[s] = <span class="number">0.0</span>;</span><br><span class="line">       <span class="comment">// relax vertices in order of distance from s</span></span><br><span class="line">       pq = <span class="keyword">new</span> IndexMinPQ&lt;Double&gt;(G.V());</span><br><span class="line">       pq.insert(s, distTo[s]);</span><br><span class="line">       <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">           <span class="keyword">int</span> v = pq.delMin();</span><br><span class="line">           <span class="keyword">for</span> (DirectedEdge e : G.adj(v))</span><br><span class="line">               relax(e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// relax edge e and update pq if changed</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(DirectedEdge e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> v = e.from(), w = e.to();</span><br><span class="line">       <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + e.weight()) &#123;</span><br><span class="line">           distTo[w] = distTo[v] + e.weight();</span><br><span class="line">           edgeTo[w] = e;</span><br><span class="line">           <span class="keyword">if</span> (pq.contains(w)) pq.decreaseKey(w, distTo[w]);</span><br><span class="line">           <span class="keyword">else</span>                pq.insert(w, distTo[w]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="关于Dijkstra为什么不能含有负权值"><a href="#关于Dijkstra为什么不能含有负权值" class="headerlink" title="关于Dijkstra为什么不能含有负权值"></a>关于<code>Dijkstra</code>为什么不能含有负权值</h3><p>可以想象一下，如果有一条负边在图中。<code>Dijkstra</code>维护的优先队列，每次都是取一条最小的边出来的，而这条负边，可以使这条路无限小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(DirectedEdge e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> v = e.from(), w = e.to();</span><br><span class="line">       <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + e.weight()) &#123;   <span class="comment">//若是负边的话每次都会减小，就会不断进入优先队列！！！</span></span><br><span class="line">           distTo[w] = distTo[v] + e.weight();  </span><br><span class="line">           edgeTo[w] = e;</span><br><span class="line">           <span class="keyword">if</span> (pq.contains(w)) pq.decreaseKey(w, distTo[w]);</span><br><span class="line">           <span class="keyword">else</span>                pq.insert(w, distTo[w]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p><code>Dijkstra</code>效率取决于优先队列的效率。二叉堆的话效率为<code>O(ElogV)</code></p>
<h2 id="Topological-sort"><a href="#Topological-sort" class="headerlink" title="Topological sort"></a>Topological sort</h2><p>这种方法实现简单，效率也高，但只适用于无环图，权值可以为负。</p>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li>初始化所有顶点到源点的路径为无限大</li>
<li>对顶点进行<code>拓扑排序</code></li>
<li>按照顶点顺序，对每条相关的边进行<code>放松</code></li>
</ol>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Topological topological = <span class="keyword">new</span> Topological(G);</span><br><span class="line"><span class="keyword">if</span> (!topological.hasOrder())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Digraph is not acyclic."</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v : topological.order()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (DirectedEdge e : G.adj(v))</span><br><span class="line">        relax(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="效率-1"><a href="#效率-1" class="headerlink" title="效率"></a>效率</h3><blockquote>
<p>Topological sort algorithm computes SPT in any edgeweighted<br>DAG in time proportional to E + V</p>
</blockquote>
<h2 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h2><p>对于无负环的图一种解决方案。最直接的实现是对所有边进行<code>V-1</code>次放松,但是效率太低。复杂度高达<code>O(V*E)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V(); i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e : G.adj(v))</span><br><span class="line">            relax(e);</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>原始的版本总共进行<code>V-1</code>次放松，但其实，后面的很多次都是无效的放松，实际中不到<code>V-1</code>次就已经放松完全了。判断依据就是<code>distTo[v]</code>有无变化。</p>
<p>这种方法时间复杂度最坏情况依旧是<code>O(V*E)</code>，平均情况已经快很多了<code>O(E+V)</code></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>算法4th</p>
<p>维基百科</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/24/最小生成树,Prim和Kruskal详细学习笔记/" itemprop="url">
                  最小生成树,Prim和Kruskal详细学习笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-04-24T15:13:06+08:00" content="2016-04-24">
              2016-04-24
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>最小生成树是一副连通加权无向图中一棵权值最小的生成树。<br>最小生成树其实是<strong>最小权重生成树</strong>的简称。</p>
</blockquote>
<p>可能翻译为<code>最小权重生成树</code>更容易理解一些。意思就是说在图中的每条边都加上权值，所谓权值是一种抽象的含义。可以指代一切可以量化的东西。比如说修路的费用，路程等等。然后在图中找到这样一棵树，边的权值加起来最小。并且既然是棵树，必须满足的要求是无环.</p>
<p>一般用两种贪心算法来找到最小生成树，分别是<code>prim</code>和<code>Kruskal</code><br><a id="more"></a></p>
<h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a><code>Kruskal</code></h2><p><code>Kruskal</code> 算法，我觉得比较容易理解，实现也比较简单。</p>
<ol>
<li>新建图G</li>
<li>把图G中所有的边按照权值从小到大排序。(一般使用优先队列)</li>
<li>取出最小的边</li>
<li>如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中.(使用并查集)</li>
<li>重复3，直至图G中所有的节点都在同一个连通分量中</li>
</ol>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalMST</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Edge&gt; mst = <span class="keyword">new</span> Queue&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KruskalMST</span><span class="params">(EdgeWeightedGraph g)</span></span>&#123;</span><br><span class="line">        MinPQ&lt;Edge&gt; minPQ = <span class="keyword">new</span> MinPQ&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Edge edge:g.edges())&#123;</span><br><span class="line">            minPQ.insert(edge);</span><br><span class="line">        &#125;</span><br><span class="line">        UF uf =<span class="keyword">new</span> UF(minPQ.size());</span><br><span class="line">        <span class="keyword">while</span> (!minPQ.isEmpty())&#123;</span><br><span class="line">            Edge edge = minPQ.delMin();</span><br><span class="line">            <span class="keyword">int</span> v = edge.either();</span><br><span class="line">            <span class="keyword">int</span> w = edge.other(v);</span><br><span class="line">            <span class="keyword">if</span>(!uf.connected(v,w))&#123;</span><br><span class="line">                uf.union(v,w);</span><br><span class="line">                mst.enqueue(edge);</span><br><span class="line">                <span class="comment">//weight+=edge.weight();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p><code>Kruskal</code> 算法 基本上取决于优先队列的选择，以及并查集的实现。</p>
<p>比较优的算法效率为<code>O(ElogE)</code>E为图中的边数.</p>
<p>对优先队列和并查集不了解的同学可以看看我这两篇文章，<a href="http://threezj.com/2016/03/20/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E9%A1%BA%E5%BA%8F%E3%80%81%E4%BA%8C%E5%88%86%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E3%80%81%E7%BA%A2%E9%BB%91%E6%A0%91/">查找算法之顺序、二分、二叉搜索树、红黑树</a> 和 <a href="http://threezj.com/2016/03/12/Union-Find%20/">并查集</a></p>
<h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><p><code>Prim</code>算法，简单的说就是<code>从一个点开始不断让树长大的过程,并且保持权值最小</code>。</p>
<ol>
<li>生成图G</li>
<li>从s点开始</li>
<li>把与s点相连的边都加入<code>edgeTo[]</code>,并且保存到这些点的距离<code>distTo[]</code>,且插入到优先队列</li>
<li>出队一个点</li>
<li>查找与这个点相连的点，若权值比<code>distTo[]</code>中保存的值小则进更新，同时更新<code>distTo[]</code>和优先队列.</li>
<li>重复4</li>
</ol>
<p>如下图</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9C%9620160424222602.jpg" alt=""></p>
<h3 id="实现代码-1"><a href="#实现代码-1" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Edge[] edgeTo;        <span class="comment">// edgeTo[v] = shortest edge from tree vertex to non-tree vertex</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span>[] distTo;      <span class="comment">// distTo[v] = weight of shortest such edge</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;     <span class="comment">// marked[v] = true if v on tree, false otherwise</span></span><br><span class="line"><span class="keyword">private</span> IndexMinPQ&lt;Double&gt; pq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrimMST</span><span class="params">(EdgeWeightedGraph G)</span></span>&#123;</span><br><span class="line">    edgeTo = <span class="keyword">new</span> Edge[G.V()];</span><br><span class="line">    distTo = <span class="keyword">new</span> <span class="keyword">double</span>[G.V()];</span><br><span class="line">    marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">    pq = <span class="keyword">new</span> IndexMinPQ&lt;Double&gt;(G.V());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">        distTo[v] = Double.POSITIVE_INFINITY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)      <span class="comment">// run from each vertex to find</span></span><br><span class="line">        <span class="keyword">if</span> (!marked[v]) prim(G, v);      <span class="comment">// minimum spanning forest</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(EdgeWeightedGraph g, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    distTo[s]=<span class="number">0</span>;</span><br><span class="line">    pq.insert(s,distTo[s]);</span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty())&#123;</span><br><span class="line">        grow(g,pq.delMin());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(EdgeWeightedGraph g, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    marked[v]=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (Edge e :g.adj(v))&#123;</span><br><span class="line">        <span class="keyword">int</span> w = e.other(v);</span><br><span class="line">        <span class="keyword">if</span>(marked[w])   <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(distTo[w]&gt;e.weight())&#123;</span><br><span class="line">            distTo[w]=e.weight();</span><br><span class="line">            edgeTo[w] = e;</span><br><span class="line">            <span class="keyword">if</span>(pq.contains(w))</span><br><span class="line">                pq.decreaseKey(w,distTo[w]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pq.insert(w,distTo[w]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>具体性能也是取决于优先队列的选择，一般来说可以达到<code>O(ElogV)</code></p>
<h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><blockquote>
<p>Kruskal can have better performance if the edges can be sorted in linear time, or are already sorted.</p>
<p>Prim’s better if the number of edges to vertices is high.</p>
</blockquote>
<p>引用自<code>stackoverflow</code></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><code>维基百科</code></p>
<p><code>算法4th</code></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/15/推荐一门CMU公开课/" itemprop="url">
                  推荐一门CMU公开课
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-04-15T15:13:06+08:00" content="2016-04-15">
              2016-04-15
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>推荐一门非常有意思的公开课。<code>CMU 15213</code> 由大名鼎鼎的<code>CSAPP</code>的作者主讲。内容就是按照<code>CSAPP</code>这本书为主线进行讲解的，看不进书的同学，强烈建议直接看视频。</p>
<p>这门课最核心的内容是七个<code>lab</code>，非常非常有意思。比如第一个<code>datalab</code>，要求你只允许用<code>! ~ | &amp;amp; +</code>这些位级操作符来进行运算，很头脑风暴，可能有些人写了这么多年代码1个字节几个二进制位都不知道。</p>
<p>我刚刚做完第二个<code>boomlab</code>，通过利用<code>GDB</code>反汇编二进制文件，调试单步执行找到炸弹，要求你可以不会写汇编，但要能看懂汇编。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/QQ%E6%88%AA%E5%9C%9620160415204556.jpg" alt=""></p>
<p>最后有个实验貌似是自己实现一个malloc有兴趣的同学可以和我一起跟课。</p>
<ul>
<li><a href="http://www.cs.cmu.edu/~213/index.html" target="_blank" rel="external">CMU 15213</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/28/用拉链法和线性探测法解决哈希冲突/" itemprop="url">
                  用拉链法和线性探测法解决哈希冲突
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-28T15:13:06+08:00" content="2016-03-28">
              2016-03-28
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面学习到的几种算法比如<code>红黑树</code>，<code>二叉搜索树</code>，查找插入<code>时间复杂度</code>最快也只能到<code>O(logn)</code>.现在介绍一种算法可以使查找插入<code>时间复杂度</code>达到常数级别。</p>
<h2 id="散列表-Hash-table"><a href="#散列表-Hash-table" class="headerlink" title="散列表(Hash table)"></a>散列表(Hash table)</h2><p>也称为<code>哈希表</code>。是字典的一种抽象。比如说你要查一个字，通过这个字的拼音首字母，找到这个字的页码，然后翻到那页找就行了。这种方法直接把查找<code>时间复杂度</code>降到了常数。但是要牺牲一定的计算索引的时间。计算索引的那个函数称为<code>哈希函数</code>(<code>散列函数``)。如果两个不同的</code>key`算出了同一个索引，此时就要用到一定的方法来解决哈希冲突。<br><a id="more"></a></p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p><code>哈希函数</code>一般具有如下特点。</p>
<ul>
<li>相等的<code>key</code>产生相等的<code>哈希值</code></li>
<li>计算简单方便</li>
<li><code>哈希值</code>均匀分布。(若过度集中，则容易使效率降低到<code>o(n)</code>)</li>
</ul>
<p>构造<code>哈希函数</code>有多种方法，这里不详细讲解。</p>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>若两个不相等的<code>key</code>产生了相等的<code>哈希值</code>，这时则需要采用<code>哈希冲突</code>。</p>
<h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p><code>Java</code>标准库的<code>HashMap</code>基本上就是用<code>拉链法</code>实现的。<code>拉链法</code>的实现比较简单，将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160328161219.jpg" alt=""></p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ul>
<li>得到一个<code>key</code></li>
<li>计算<code>key</code>的<code>hashValue</code></li>
<li>根据<code>hashValue</code>值定位到<code>data[hashValue]</code>。(<code>data[hashValue]</code>是一条链表)</li>
<li>若<code>data[hashValue]</code>为空则直接插入</li>
<li>不然则添加到表头</li>
</ul>
<p>这里需要注意的是，<code>哈希函数</code>必须保证<code>哈希值</code>的<code>均匀分布</code>，若全部集中在一条链表中，则<code>时间复杂度</code>和顺序链表相同。</p>
<p>还有一点则是数组的大小，若你能估计数据的大小，则直接指定即可，否则就需要<code>动态扩充</code>数组。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeparateChainingHashST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//这里的M需要根据实际情况调整</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">SeparateChainingHashST</span><span class="params">(<span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.M = M;</span><br><span class="line">            st = (SequentialSearchST&lt;Key, Value&gt;[]) <span class="keyword">new</span> SequentialSearchST[M];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">                st[i]=<span class="keyword">new</span> SequentialSearchST&lt;Key,Value&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key k,Value v)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hashValue = hash(k);</span><br><span class="line">            st[hashValue].put(k,v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key k)</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> hashValue = hash(k);</span><br><span class="line">            <span class="keyword">return</span> st[hashValue].get(k);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性探测"><a href="#线性探测" class="headerlink" title="线性探测"></a>线性探测</h3><p><code>线性探测</code>直接使用数组来存储数据。可以想象成一个停车问题。若当前车位已经有车，则你就继续往前开，直到找到下一个为空的车位。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160328162810.jpg" alt=""></p>
<h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><ul>
<li>得到<code>key</code></li>
<li>计算得<code>hashValue</code></li>
<li>若不冲突，则直接填入数组</li>
<li>若冲突，则使<code>hashValue++</code>，也就是往后找，直到找到第一个<code>data[hashValue]</code>为空的情况,则填入。若到了尾部可循环到前面。</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinearProbingHashST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LinearProbingHashST</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        keys = (Key[]) <span class="keyword">new</span> Object[cap];</span><br><span class="line">        values = (Value[]) <span class="keyword">new</span> Object[cap];</span><br><span class="line">        M = cap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key.hashCode() &amp; <span class="number">0x7fffffff</span>) % M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="comment">//若当前数据含量超过了总容量的一半，则重新调整容量</span></span><br><span class="line">        <span class="keyword">if</span>(N&gt;=M/<span class="number">2</span>) resize(<span class="number">2</span>*M);  </span><br><span class="line">        <span class="keyword">int</span> hashValue = hash(key);</span><br><span class="line">        <span class="keyword">if</span> (values[hashValue]==<span class="keyword">null</span>)&#123;</span><br><span class="line">            keys[hashValue] = key;</span><br><span class="line">            values[hashValue] = value;</span><br><span class="line">            N++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(keys[hashValue].equals(key))&#123;</span><br><span class="line">            values[hashValue]=value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (values[hashValue] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                hashValue = (hashValue+<span class="number">1</span>)%M;</span><br><span class="line">            &#125;</span><br><span class="line">            keys[hashValue] = key;</span><br><span class="line">            values[hashValue] = value;</span><br><span class="line">            N++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hashValue = hash(key);</span><br><span class="line">        <span class="keyword">if</span> (keys[hashValue]!=<span class="keyword">null</span>&amp;&amp;!keys[hashValue].equals(key))&#123;</span><br><span class="line">            <span class="keyword">while</span> (keys[hashValue]!=<span class="keyword">null</span> &amp;&amp;keys[hashValue]!=key)&#123;</span><br><span class="line">                hashValue = (hashValue+<span class="number">1</span>)%M;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> values[hashValue];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h2><p>一般来说，使用<code>散列表</code>会比<code>红黑树</code>快很多。但具体还是要看<code>哈希函数</code>的计算效率。但是<code>散列表</code>无法保证顺序，所以如果你需要进行有关顺序的操作，应该使用<code>红黑树</code>或者<code>二叉搜索树</code>。</p>
<p>对于<code>线性探测</code>来说动态调整数组大小是必要的，不然会产生死循环。</p>
<p><code>拉链法</code>的删除操作比较方便，直接链表修改地址即可。而<code>线性探测</code>删除操作很复杂，而且<code>线性探测</code>耗费的内存比拉链法要多。</p>
<p>分别对四个文件进行插入搜索操作。</p>
<ul>
<li><code>tale.txt</code>(779kb)<br>顺序查找(7.143秒) 二分查找(0.46秒) <code>二叉搜索树</code>(0.191秒) <code>红黑树</code>(0.237秒) <code>拉链法</code>(0.124秒) <code>线性探测</code>(0.103秒)</li>
<li><code>leipzig100k.txt</code>(12670kb)<br>顺序查找(无) 二分查找(13.911秒) <code>二叉搜索树</code>(1.389秒) <code>红黑树</code>(1.442秒)<br><code>拉链法</code>(0.707秒) <code>线性探测</code>(0.562秒)</li>
<li><code>leipzig300k.txt</code>(37966kb)<br>顺序查找(无) 二分查找(60.222秒) <code>二叉搜索树</code>(2.742秒) <code>红黑树</code>(3.104秒)<br><code>拉链法</code>(1.839秒) <code>线性探测</code>(1.559秒)</li>
<li><code>leipzig1m.txt</code>(126607kb)<br>顺序查找(无) 二分查找(无) <code>二叉搜索树</code>(3.016秒) <code>红黑树</code>(2.797秒)<br><code>拉链法</code>(3.938秒) <code>线性探测</code>(3.668秒)</li>
</ul>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160328190932.jpg" alt=""></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><code>维基百科</code></p>
<p><a href="http://www.amazon.cn/%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6-%E7%AE%97%E6%B3%95-%E5%A1%9E%E5%A5%87%E5%A8%81%E5%85%8B/dp/B009OCFQ0O/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1457882078&amp;sr=1-1&amp;keywords=%E7%AE%97%E6%B3%95" target="_blank" rel="external">算法 4th</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/20/查找算法之顺序、二分、二叉搜索树、红黑树 详细比较总结/" itemprop="url">
                  查找算法之顺序、二分、二叉搜索树、红黑树 详细比较总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-20T15:13:06+08:00" content="2016-03-20">
              2016-03-20
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般用<code>符号表</code>来储存键值对，就好像字典那样，通过索引来查找值，若键重复则覆盖值。我们能希望找到一种高效的查找算法使在平均情况和最差情况下，时间复杂度都能达到<code>O(logn)</code>。下面会逐步介绍四种算法，最终达到我们的目的。</p>
<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>用链表实现，无法索引数据，必须遍历找数据，速度比较慢，查找插入时间复杂度都为<code>O(n)</code>，而且无法保证有序。但是实现简单，适用于小型数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SequentialSearchST</span>&lt;<span class="title">Key</span>,<span class="title">Value</span>&gt;  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value v)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Node p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.key.equals(key))&#123;</span><br><span class="line">                p.v=v;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        head=<span class="keyword">new</span> Node(key,v,head);</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        Node p=head;</span><br><span class="line">        <span class="keyword">while</span> (p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.key.equals(key))&#123;</span><br><span class="line">                <span class="keyword">return</span>  p.v;</span><br><span class="line">            &#125;</span><br><span class="line">            p=p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>用数组保存数据，保证有序。二分查找速度很快，但是仅限于查找。因为插入的时候要保证有序，所以要往后移动数据以便插入。查找复杂度<code>O(logn)</code>,插入复杂度<code>O(n)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>,<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index=rank(key);</span><br><span class="line">        <span class="comment">//键相等则覆盖值</span></span><br><span class="line">        <span class="keyword">if</span>(keys[index]!=<span class="keyword">null</span>&amp;&amp;key.compareTo(keys[index])==<span class="number">0</span>)&#123; </span><br><span class="line">            values[index]=value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把数据往后移，以便插入</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=size+<span class="number">1</span>;i&gt;index;i--)&#123;</span><br><span class="line">            keys[i]=keys[i-<span class="number">1</span>];</span><br><span class="line">            values[i]=values[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        keys[index]=key;</span><br><span class="line">        values[index]=value;</span><br><span class="line">        size++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index=rank(key);<span class="comment">//二分查找</span></span><br><span class="line">        <span class="keyword">if</span>(keys[index]!=<span class="keyword">null</span> &amp;&amp; key.compareTo(keys[index])==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> values[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key)</span></span>&#123;<span class="keyword">return</span> rank(key,<span class="number">0</span>,size);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(Key key,<span class="keyword">int</span> l,<span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;h) <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">int</span> mid = (l+h)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(keys[mid]!=<span class="keyword">null</span>)</span><br><span class="line">            cmp=key.compareTo(keys[mid]);</span><br><span class="line">        <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> rank(key,l,mid-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> rank(key,mid+<span class="number">1</span>,h);</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a><code>二叉搜索树</code></h2><p>通过前面两个算法，我们可以知道链表能快速删除插入，而二分能快速查找。所以我们想找到一种结构既是链式结构，同时又能进行二分查找，同时保证查找和插入的高效性。</p>
<p>答案就是<code>二叉搜索树</code>。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>是二叉树</li>
<li>每个节点含有一个键和关联的值</li>
<li>每个节点大于左子树上所有结点的值且小于右子树上所有节点的值</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>其实给出定义，实现就已经很清楚了。说白了就是从无到有构造一个二叉树，每次插入都和树中的节点进行比较，小的放左边，大的放右边。就如同<code>快速排序</code>，用一个主元把左右两边分开。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320221749.jpg" alt=""></p>
<p>还是直接看代码清楚点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>,<span class="title">Value</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">put</span><span class="params">(Node x, Key key, Value value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>) x.left=put(x.left,key,value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>) x.right=put(x.right,key,value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            x.value=value;</span><br><span class="line">            x.N = size(x.right)+size(x.left)+<span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Value <span class="title">get</span><span class="params">(Key key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(root,key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Value <span class="title">get</span><span class="params">(Node x, Key key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> cmp =key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>)   <span class="keyword">return</span> get(x.left,key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>) <span class="keyword">return</span> get(x.right,key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h3><p><code>二叉搜索树</code>的查找和搜索在平均情况下时间复杂度都能达到<code>O(logn)</code>，而且能保证数据有序。<code>二叉搜索树</code>的中序遍历就是数据的顺序。我们貌似已经找到了一个最理想的算法。</p>
<p>但是这个效率只是在平均情况下。如果数据是逆序，或者顺序，那么这棵树就会发生一边倒的情况使复杂度直接达到<code>O(n)</code>，就如同快排中选择到糟糕的主元(最大或者最小)。比快排糟糕的是，<code>快排</code>我们能通过随机打乱数据来避免这种情况发生。但<code>二叉搜索树</code>则不行，数据都是客户提供，直接插入到树中的，这种情况其实经常发生。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320222706.jpg" alt=""></p>
<p>幸运的是我们有<code>平衡二叉树</code>可以解决这个问题。</p>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a><code>平衡二叉树</code></h2><h3 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a><code>2-3树</code></h3><p>为了保持树平衡性，允许节点能保存两个键值对，且能连三个儿子。这样把节点分成了两种类型。</p>
<ul>
<li><code>2-节点</code> : 一个键值对，两个儿子。 (也就是标准的<code>二叉搜索树</code>)</li>
<li><code>3-节点</code> : 两个键值对，三个儿子。 (两个键是有序的，左小右大。左儿子小于左边的键，右儿子大于右边的键，中间的儿子在两个键之间)</li>
</ul>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320225636.jpg" alt=""></p>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><code>2-3树</code>插入比较复杂。在插入的同时保持平衡性。</p>
<ul>
<li>向<code>2-节点</code>中插入键。这种情况比较简单。直接插入即可。</li>
<li>向<code>3-节点</code>中插入键。比较特殊。先暂时把键插入到<code>3-节点</code>，此时这个节点中就有了三个键，然后再把这个节点分开。把中间的儿子简单当根，左右两边的键当儿子。若父节点还是<code>3-节点</code>，则继续递归进行。</li>
</ul>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/search2-3_insertion.svg.png" alt=""></p>
<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p><code>2-3树</code>性能可以说是比较好的。不管数据怎么样，查找删除操作时间复杂度都能达到O(logn)。<br>但是<code>2-3树</code>实现比较复杂，需要掌控的情况很多，剥离节点，传递节点等操作，都需要很复杂的代码，且也会耗费不少的时间。所以我们一般不怎么用原始的<code>2-3树</code>，而是用<code>2-3树</code>的变形<code>红黑树</code>.</p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a><code>红黑树</code></h3><p><code>红黑树</code>最方便的地方除了插入和删除操作的代码略复杂以外，另外的操作都可以直接复制<code>二叉搜索树</code>。</p>
<p><code>红黑树</code>是<code>2-3树</code>的变形，把<code>3-节点</code>分离开来使之成为普通的<code>2-节点</code>。但是怎么表现分离开的节点之间的联系呢。我们用红线把他们连起来。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320231811.jpg" alt=""></p>
<p>巧妙地结合<code>二叉搜索树</code>的高效查找操作和<code>2-3树</code>的平衡插入操作。</p>
<p>每个节点都只有一根连向父节点的线。这个线的颜色称为节点的颜色。</p>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>我们通过旋转来维持树的平衡。一般有两种情况需要旋转。</p>
<ul>
<li>连续两个左节点的颜色为红色,向右转</li>
<li>右节点的颜色为红色，向左转</li>
<li>第三种情况是左右两边都为红色。最好处理，不需要旋转。只需要把左右两个儿子的颜色改成黑色，再把自己的颜色改成黑色。可以想象成把3个键值对<code>3-节点</code>剥离开。</li>
</ul>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320232738.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackRedBST</span>&lt;<span class="title">Key</span> <span class="keyword">extends</span> <span class="title">Comparable</span>,<span class="title">Value</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Key key,Value value)</span></span>&#123;</span><br><span class="line">        root = put(root,key,value);</span><br><span class="line">        root.color = BLACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">put</span><span class="params">(Node x, Key key, Value value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key,value,<span class="number">0</span>,RED);</span><br><span class="line">        <span class="keyword">int</span> cmp = key.compareTo(x.key);</span><br><span class="line">        <span class="keyword">if</span>(cmp&lt;<span class="number">0</span>) x.left = put(x.left,key,value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp&gt;<span class="number">0</span>) x.right = put(x.right,key,value);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cmp==<span class="number">0</span>) x.value =value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( isRED(x.right) &amp;&amp; !isRED(x.left)) x=rotateLeft(x);</span><br><span class="line">        <span class="keyword">if</span>( isRED(x.left) &amp;&amp; isRED(x.left.left)) x=rotateRight(x);</span><br><span class="line">        <span class="keyword">if</span>( isRED(x.left) &amp;&amp; isRED(x.right)) flipColor(x);</span><br><span class="line">        x.N = size(x.right) + size(x.left) +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>  x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flipColor</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        x.right.color = BLACK;</span><br><span class="line">        x.left.color = BLACK;</span><br><span class="line">        x.color = RED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotateLeft</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        Node r =x.right;</span><br><span class="line">        x.right = r.left;</span><br><span class="line">        r.left = x;</span><br><span class="line">        r.color = x.color;</span><br><span class="line">        x.color = RED;</span><br><span class="line">        x.N = size(x.left)+size(x.right) +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">rotateRight</span><span class="params">(Node x)</span> </span>&#123;</span><br><span class="line">        Node r =x.left;</span><br><span class="line">        x.left = r.right;</span><br><span class="line">        r.right = x;</span><br><span class="line">        r.left.color = RED;</span><br><span class="line">        r.right.color = RED;</span><br><span class="line">        r.color =BLACK;</span><br><span class="line">        x.N = size(x.left)+size(x.right) +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><p>无论数据如何，插入删除时间复杂度都为<code>O(logn)</code>，可以说达到了理想状态，且代码简单。</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>分别对四个文件进行插入搜索操作。</p>
<ul>
<li><code>tale.txt</code>(779kb)<br>顺序查找(7.143秒) 二分查找(0.46秒) <code>二叉搜索树</code>(0.191秒) <code>红黑树</code>(0.237秒)</li>
<li><code>leipzig100k.txt</code>(12670kb)<br>顺序查找(无) 二分查找(13.911秒) <code>二叉搜索树</code>(1.389秒) <code>红黑树</code>(1.442秒)</li>
<li><code>leipzig300k.txt</code>(37966kb)<br>顺序查找(无) 二分查找(60.222秒) <code>二叉搜索树</code>(2.742秒) <code>红黑树</code>(3.104秒)</li>
<li><code>leipzig1m.txt</code>(126607kb)<br>顺序查找(无) 二分查找(无) <code>二叉搜索树</code>(3.016秒) <code>红黑树</code>(2.797秒)</li>
</ul>
<p>由上面的数据分析，顺序查找实际是非常慢的。而二分查找对小型数据还是比较快，但是数据一大就不行了。</p>
<p>而这里的<code>二叉搜索树</code>和<code>红黑树</code>，无论什么数据效率都是极高。而且由<code>leipzig300k.txt</code>到<code>leipzig1m.txt</code>数据几乎翻了4倍，而这两种算法的效率几乎没收什么影响。</p>
<p>这里因为我的数据比较平均的关系，比较不出红黑树和二叉搜索树的差异。我自己构造了一组数据进行测试。完全逆序的<code>100000</code>个数进行插入删除。</p>
<ul>
<li>红黑树(0.173秒)</li>
<li>二叉搜索树(StackOverflow)</li>
</ul>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/searchQQ%E6%88%AA%E5%9C%9620160320233331.jpg" alt=""></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>维基百科</p>
<p><a href="http://www.amazon.cn/%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6-%E7%AE%97%E6%B3%95-%E5%A1%9E%E5%A5%87%E5%A8%81%E5%85%8B/dp/B009OCFQ0O/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1457882078&amp;sr=1-1&amp;keywords=%E7%AE%97%E6%B3%95" target="_blank" rel="external">算法 4th</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/16/复杂排序之归并、快速、三向切分、堆排序 详细总结/" itemprop="url">
                  复杂排序之归并、快速、三向切分、堆排序 详细总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-16T15:13:06+08:00" content="2016-03-16">
              2016-03-16
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="归并排序-MergeSort"><a href="#归并排序-MergeSort" class="headerlink" title="归并排序(MergeSort)"></a>归并排序(MergeSort)</h2><p>复杂度<code>O(nlogn)</code>.</p>
<p>核心思想就是采用分而治之的方法，递归的合并两个有序的数组。效率比较高，缺点是空间复杂度高，会用到额外的数组。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>核心代码是合并的函数。合并的前提是保证左右两边的数组分别有序，在合并之前和之后在<code>Java</code>中我们可以用断言来保证数组有序。</p>
<p>合并的原理其实也很简单，先把<code>a</code>数组中的内容复制到额外储存的<code>temp</code>数组中去。分别用两个<code>index</code>指向<code>a</code>数组的起始位置和中间位置，保证<code>a</code>数组左右两边有序，比如<code>i</code>，<code>j</code>。现在开始从头扫描比较左右两个数组,若<code>a[i]&amp;lt;=a[j]</code>，则把<code>a[i]</code>放到<code>temp</code>数组中去，且<code>i</code>向前走一步。反正则放<code>a[j]</code>，且<code>j</code>走一步。若其中一个数组走完了，则把另一个数组剩余的数直接放到temp数组中。</p>
<p>我们用递归的方式来实现左右两边有序。递归到数组只有1个数时肯定是有序的，再合并2个数，再退出来合并4个数，以此类推。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/sortMerge-sort-example-300px.gif" alt=""></p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/sortQQ%E6%88%AA%E5%9C%9620160316182738.jpg" alt=""><br><a id="more"></a></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> <span class="keyword">extends</span> <span class="title">BaseSort</span> </span>&#123;</span><br><span class="line">    Comparable[] temp ;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(Comparable[] a, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> h)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=h;i++)&#123;</span><br><span class="line">            temp[i]=a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i=l;</span><br><span class="line">        <span class="keyword">int</span> j=m+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;=h;k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;m) a[k]=temp[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;h) a[k]=temp[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(less(temp[i],temp[j])) a[k]=temp[i++];</span><br><span class="line">            <span class="keyword">else</span> a[k] = temp[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a,<span class="keyword">int</span> l,<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;h)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+h)/<span class="number">2</span>;</span><br><span class="line">            sort(a,l,mid);</span><br><span class="line">            sort(a,mid+<span class="number">1</span>,h);</span><br><span class="line">            merge(a,l,mid,h);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        temp = <span class="keyword">new</span> Comparable[a.length];</span><br><span class="line"></span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>归并排序对小数组排序时，由于会有多重的递归调用，所以速度没有插入排序快。可以在递归调用到小数组时改采用插入排序。小数组的意思是差不多10个数左右。</p>
<p>如果递归时判断已经有序则不用继续递归。也可以增加效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a,<span class="keyword">int</span> l,<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&lt;h)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l+h)/<span class="number">2</span>;</span><br><span class="line">            sort(a,l,mid);</span><br><span class="line">            sort(a,mid+<span class="number">1</span>,h);</span><br><span class="line">            <span class="keyword">if</span> (!less(a[mid+<span class="number">1</span>], a[mid])) <span class="keyword">return</span>;</span><br><span class="line">            merge(a,l,mid,h);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>另外在合并时交互两个数组的顺序，能节省复制数组到辅助数组的时间，但节省不了空间。<br><img src="http://7xrsib.com1.z0.glb.clouddn.com/sortQQ%E6%88%AA%E5%9C%9620160316185505.jpg" alt=""></p>
<h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>如果你对空间要求不高，且想要一个稳定的算法。那么可以使用归并排序。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>传说中最快的排序算法，听说能裸写快排，月薪可上10k（ps.不是我说的。）</p>
<p>快排平均情况下时间复杂度<code>O(nlogn)</code>，最糟糕情况<code>O(n²)</code>。<code>O(n²)</code>主要是因为选定的主元是极端值造成的，比如说最大值，最小值。不过这种情况一般很少出现，所以在进行快排之前我们需要对数组进行乱序，尽量避免这种情况的发生，</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>第一步打乱数组。</p>
<p>然后也是分治法。归并是先分再合并。快排是先排序再分别排序两边。</p>
<p>排序过程核心思想是为了选出一个数，把数组分成左右两边，左边比主元小，右边比主元大。</p>
<p>选定第一个数作为主元。然后设定两个index指向数组首尾，比如<code>i</code>，<code>j</code>。接着从两边向中间扫描，分别用<code>a[i]</code>和<code>a[j]</code>和主元比较。若两边位置不对则交换<code>a[i]</code>和<code>a[j]</code>，比如说<code>a[i]</code>在扫描过程中遇到<code>a[i]&amp;gt;主元</code>，那么则停止扫描,因为我们需要左边的数小于主元,反正右边也一样等到<code>a[j]</code>也停下来,则交换<code>a[i]</code>和<code>a[j]</code>.</p>
<p>得到中间的位置之后再分别左右递归排序。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/sortSorting_quicksort_anim.gif" alt=""></p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/sortQQ%E6%88%AA%E5%9C%9620160316192502.jpg" alt=""></p>
<h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><p>第一步的随机打乱数组，虽然会耗费一定时间，但却是必要的。</p>
<p>同样的小数组的排序，快排不如插入排序。所以小数组可以直接采用插入排序。</p>
<p>主元的选择方式可以有多种，比如随机选择主元。或者选取三个数，取中位数为主元，但是会耗费一定时间。</p>
<h3 id="适用范围-1"><a href="#适用范围-1" class="headerlink" title="适用范围"></a>适用范围</h3><p>虽然快速排序是不稳定的。但快速排序通常明显比其他<code>Ο(nlogn)</code>算法更快，因为它的内部循环很小。</p>
<p>快速排序在对重复数据的排序时，会重复划分数据进行排序。虽然性能也还行，但这里可以进行改进，就是下面介绍的三向切分排序。</p>
<h2 id="三向切分-3-way-partitioning"><a href="#三向切分-3-way-partitioning" class="headerlink" title="三向切分(3-way partitioning)"></a>三向切分(3-way partitioning)</h2><p>快速排序的一种改进，使快排在有大量重复元素的数据，同样能保持高效。</p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>基本原理和快排差不多。三向切分的时候在划分数组时不是分为两组，而是分成三组。</p>
<ul>
<li>小于主元</li>
<li>和主元相等</li>
<li>大于主元</li>
</ul>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/sortQQ%E6%88%AA%E5%9C%9620160316194034.jpg" alt=""></p>
<p>具体排序方式和快排差不多我就不赘述了，我觉得三向切分代码写起来比快排要简单。大家直接看代码吧</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeWaySort</span> <span class="keyword">extends</span> <span class="title">BaseSort</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        sort(a,<span class="number">0</span>,a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a,<span class="keyword">int</span> l ,<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=h) <span class="keyword">return</span>;</span><br><span class="line">        Comparable v = a[l];</span><br><span class="line">        <span class="keyword">int</span> i=l;</span><br><span class="line">        <span class="keyword">int</span> lv=l;</span><br><span class="line">        <span class="keyword">int</span> gh=h;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=gh)&#123;</span><br><span class="line">            <span class="keyword">int</span> cmpIndex = a[i].compareTo(v);</span><br><span class="line">            <span class="keyword">if</span>(cmpIndex&lt;<span class="number">0</span>) exch(a,i++,lv++);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cmpIndex&gt;<span class="number">0</span>) exch(a,i,gh--);</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(a,l,lv-<span class="number">1</span>);</span><br><span class="line">        sort(a,gh+<span class="number">1</span>,h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>时间复杂度<code>O(nlogn)</code>，堆排序主要用二叉堆实现，在讲堆排序之前我们可以要先了解下二叉堆。</p>
<h3 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h3><p>所谓的二叉堆用一颗二叉树表示，也就是每一个节点都大于它的左右子节点。也就是说根节点是最大的。</p>
<p>二叉树用数组存储，可以用下标来表示节点。比如<code>i</code>这个节点的父节点为<code>i/2</code>，左儿子为<code>2*i</code>，右儿子为<code>2*i+1</code>.</p>
<p>堆的操作主要有两种上浮和下沉。主要对应两种情况，比如在数组末尾添加节点，此时需要上浮节点，保证二叉堆的特点。反之在替换根节点是则需要下沉操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上浮</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k/<span class="number">2</span>&gt;=<span class="number">1</span> &amp;&amp; less(pq[k/<span class="number">2</span>],pq[k]))&#123;</span><br><span class="line">        exch(pq,k/<span class="number">2</span>,k);</span><br><span class="line">        k=k/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下沉</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span>*k&lt;N)&#123;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">if</span>(less(pq[j],pq[j+<span class="number">1</span>])) j++;</span><br><span class="line">        <span class="keyword">if</span>(less(pq[k],pq[j])) exch(pq,k,j);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序实现原理"><a href="#堆排序实现原理" class="headerlink" title="堆排序实现原理"></a>堆排序实现原理</h3><p>分为两步。</p>
<ul>
<li>把数组排成二叉堆的顺序</li>
<li>调换根节点和最后一个节点的位置，然后对根节点进行下沉操作。</li>
</ul>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/4/4d/Heapsort-example.gif" alt=""></p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>可能我的代码和上面的动画略有出入，不过基本原理差不多。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> <span class="keyword">extends</span> <span class="title">BaseSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        N =a.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = N/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            sink(a,k);</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k&lt;=N)&#123;</span><br><span class="line">            exch(a,k,N--);</span><br><span class="line">            sink(a,k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="适用范围-2"><a href="#适用范围-2" class="headerlink" title="适用范围"></a>适用范围</h3><p>堆排序也是不稳定的。<br>堆排序在空间和时间上都是<code>O(nlogn)</code>,且没有最糟情况，但在平均情况下比快排慢。<br>所以现在大部分应用都是用的快排，因为它的平均效率很高，几乎不会有最糟情况发生。<br>但如果你的应用非常非常重视性能的保证，比如一些医学上的监控之类的。那么可以使用堆排序。<br>还有一个堆排序的缺点，是它无法利用缓存，几乎很少和相邻元素的比较。</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>我测试了一下,用10000个数据，排序100次。使用上述四个算法的运行时间如下。</p>
<blockquote>
<p>冒泡排序 26.196000000000005<br>选择排序 9.046000000000006<br>插入排序 11.630999999999998<br>希尔排序 0.20900000000000016<br>归并排序 0.24100000000000016<br>快速排序 0.16800000000000012<br>三向快速排序 0.18300000000000013<br>堆排序 0.18800000000000014</p>
</blockquote>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/sortQQ%E6%88%AA%E5%9C%9620160316203033.jpg" alt=""></p>
<p>同时推荐一个很好的网站，对各种算法进行了总结，和动画描述。</p>
<p><a href="http://www.sorting-algorithms.com/" target="_blank" rel="external">sorting-algorithms</a></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>维基百科</p>
<p><a href="http://www.amazon.cn/%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6-%E7%AE%97%E6%B3%95-%E5%A1%9E%E5%A5%87%E5%A8%81%E5%85%8B/dp/B009OCFQ0O/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1457882078&amp;sr=1-1&amp;keywords=%E7%AE%97%E6%B3%95" target="_blank" rel="external">算法 4th</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/13/简单排序之冒泡、选择、插入、希尔详细总结/" itemprop="url">
                  简单排序之冒泡、选择、插入、希尔详细总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-13T15:13:06+08:00" content="2016-03-13">
              2016-03-13
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文讲述一些简单算法的实现和效率比较。所有代码用<code>java</code>实现。用到的两个基本的<code>api</code>代码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(Comparable v,Comparable w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v.compareTo(w) &lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(Comparable[] a,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    Comparable temp = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h2><p>一般算法入门，都是用冒泡做的例子。但实际中基本很难用到，复杂度<code>O(n²)</code>。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>一趟一趟的比，每一趟中，循环剩余的数，和后一个进行比较，若比它小则交换。这样一趟下来最小的在第一个，最大的在最后一个。总共比<code>n-1</code>趟。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Bubblesort implements Sortable &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sort(Comparable[] a) &#123;</span><br><span class="line">        for(int i=0;i&lt;a.length-1;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;a.length-1-i;j++)&#123;</span><br><span class="line">                if(less(a[j+1],a[j]))&#123;</span><br><span class="line">                    exch(a,j,j+1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>上面的算法，无论的你的数据怎么样，始终都要比<code>n²</code>次，效率很低。若你的数据局部有序，经过几趟交换以后，已经有序，则不用继续往下比。效率会高很多。优化代码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubblesort</span> <span class="keyword">implements</span> <span class="title">Sortable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> didSwap = flase;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;a.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(less(a[j+<span class="number">1</span>],a[j]))&#123;</span><br><span class="line">                    exch(a,j,j+<span class="number">1</span>);</span><br><span class="line">                    didSwap = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!didSwap) <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="选择排序-Selection-sort"><a href="#选择排序-Selection-sort" class="headerlink" title="选择排序(Selection sort)"></a>选择排序(Selection sort)</h2><p>和冒泡复杂度一样<code>O(n²)</code>，但是时间上可能会比冒泡稍微快一点，因为交换的次数比冒泡少。</p>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>选择排序可以说是最好理解的算法。就是每次遍历一趟，找出最小的数，放到最前端。（这里说的是最前，是指无序的队列中的最前）</p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Selection</span> <span class="keyword">implements</span> <span class="title">Sortable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;a.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(less(a[j],a[min]))&#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            exch(a,i,min);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>时间复杂度O(n²)。</p>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>遍历未排序序列。把未排序数列的第一个数和已排序数列的每一个数比较，若比它大则交换。经典的理解方式就是理解成摸牌时候理牌的顺序。我上面的实现是直接交互数字，若是把大的数直接往后移效率还会更高。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/sortQQ%E6%88%AA%E5%9C%9620160313220945.jpg" alt=""></p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Insertion</span> <span class="keyword">implements</span> <span class="title">Sortable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;a.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(less(a[j],a[j-<span class="number">1</span>]))&#123;</span><br><span class="line">                    exch(a,j,j-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="适合插入排序的数据"><a href="#适合插入排序的数据" class="headerlink" title="适合插入排序的数据"></a>适合插入排序的数据</h3><p>当你的数据是基本有序的时候且数据量小，利用插入排序的时候，效率会很高。若数据为逆序的话，效率很低。</p>
<h2 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序(Shell Sort)"></a>希尔排序(Shell Sort)</h2><p>可以看出是插入排序的一种优化，或者是预处理。希尔排序就是先进行<code>h-sort</code>，也就是让间隔为<code>h</code>的元素都是有序的。普通的插入排序就是<code>1-sort</code>。</p>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>主要就是选定一个h的有序数组来进行预排序。这样最后进行插入排序的时候，能使数据局部有序。就算交换的话，交换的次数也不会很多。这样h序列称为<code>递增序列</code>。希尔的性能很大部分取决于<code>递增序列</code>.一般来说我们使用这个序列<code>3x + 1</code>.</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/sortQQ%E6%88%AA%E5%9C%9620160313224750.jpg" alt=""></p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> <span class="keyword">implements</span> <span class="title">Sortable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparable[] a)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h&lt;a.length/<span class="number">3</span>)&#123;</span><br><span class="line">            h=<span class="number">3</span>*h+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(h&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=h;i&lt;a.length;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=h;j=j-h)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(less(a[j],a[j-h]))&#123;</span><br><span class="line">                        exch(a,j,j-h);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h=h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>对于希尔排序的性能其实无法准确表示。介于<code>O(nlogn)</code>和<code>O(n²)</code>之间，大概在n的1.5次幂左右。</p>
<p>希尔排序对于中大型数据的排序效率是很高的，而且占用空间少，代码量短。而且就算是很大的数据，用类似快排这种高性能的排序方法，也仅仅只比希尔快两倍或者不到。</p>
<h2 id="运行时间比较"><a href="#运行时间比较" class="headerlink" title="运行时间比较"></a>运行时间比较</h2><p>我测试了一下,用5000个数据，排序100次。使用上述四个算法的运行时间如下。</p>
<blockquote>
<p>冒泡排序 5.734000000000004</p>
<p>选择排序 2.351</p>
<p>插入排序 2.720999999999999</p>
<p>希尔排序 0.09400000000000007</p>
</blockquote>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.amazon.cn/%E5%9B%BE%E7%81%B5%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%9B%E4%B9%A6-%E7%AE%97%E6%B3%95-%E5%A1%9E%E5%A5%87%E5%A8%81%E5%85%8B/dp/B009OCFQ0O/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1457882078&amp;sr=1-1&amp;keywords=%E7%AE%97%E6%B3%95" target="_blank" rel="external">算法 4th</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/12/Union-Find/" itemprop="url">
                  Union-Find
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-12T15:13:06+08:00" content="2016-03-12">
              2016-03-12
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开始刷<code>Coursera</code>的<code>Algorithms</code>课，在此尽量为每个<code>Lectures</code>写篇笔记。</p>
<h2 id="Union-Find"><a href="#Union-Find" class="headerlink" title="Union-Find"></a>Union-Find</h2><p>并查集，顾名思义，主要两个操作。</p>
<ul>
<li><code>union</code>  合并两个集合</li>
<li><code>find</code>   查询两个对象是否属于一个集合</li>
</ul>
<p>一个集合称为<code>Connected components</code>.</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/union-find2.jpg" alt=""><br><a id="more"></a></p>
<h2 id="quick-find"><a href="#quick-find" class="headerlink" title="quick-find"></a>quick-find</h2><p>用数组来保存数据。若两个数据的索引在数组中的值一样，则称两个数据在一个集合。</p>
<ul>
<li><p><code>union(p,q)</code> 也就是<code>data[p]=data[q]</code>,但是注意，所有和p在同一个集合的数都要链接到q集合。所以这里需要一个循环操作。</p>
</li>
<li><p><code>find(p,q)</code>  判断 <code>data[p]==data[q]</code></p>
</li>
</ul>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/union-findQQ%E6%88%AA%E5%9C%9620160312144918.jpg" alt=""></p>
<p>主要代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data[];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QF</span><span class="params">()</span></span>&#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            data[i]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data[p]==data[q];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tp = data[p];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i]==tp)</span><br><span class="line">                data[i]=data[q];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法查询效率很高。但是合并效率低。如果要合并n个集合，集合总共有m个数据，时间复杂度就是n的平方了，</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/union-findQQ%E6%88%AA%E5%9C%9620160312150842.jpg" alt=""></p>
<h2 id="quick-union"><a href="#quick-union" class="headerlink" title="quick-union"></a>quick-union</h2><p>此方法改变集合存储方式，以一颗树的方式来存储。每次合并的时候只要改变根节点即可。</p>
<p>主要储存方式为，比如说<code>index=1</code>的节点的父亲节点为<code>data[1]</code>,<code>index=1</code>的祖父节点为<code>data[data[1]]</code>，以此类推，如果<code>data[i]==i</code>,则找到了根节点。</p>
<ul>
<li><p><code>union(p,q)</code> 改变p的根节点数组数据为q的根节点。即<code>data[root(p)]=root(q)</code></p>
</li>
<li><p><code>find(p,q)</code>  判断p q的根节点是否相同。</p>
</li>
</ul>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/union-findQQ%E6%88%AA%E5%9C%9620160312151450.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">      <span class="keyword">while</span>(data[r]!=r)</span><br><span class="line">          r=data[r];</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> root(p)==root(q);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> rq=root(q);</span><br><span class="line">      <span class="keyword">int</span> rp=root(p);</span><br><span class="line">      data[rq]=rp;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个算法比刚才的效率高了不少，唯一要担心的是<code>root()</code>方法，此方法会遍历整棵树查找根节点，如果树太高的话。效率会受到一定影响，下面我进行一些优化。</p>
<h2 id="改进quick-union"><a href="#改进quick-union" class="headerlink" title="改进quick-union"></a>改进quick-union</h2><h3 id="weighted-QU"><a href="#weighted-QU" class="headerlink" title="weighted QU"></a>weighted QU</h3><p>一个比较简单的方法是，每次在挂接树的时候。把节点较少的树挂到节点较多的树上，此方法能有效降低树的高度。</p>
<p><img src="http://7xrsib.com1.z0.glb.clouddn.com/union-findQQ%E6%88%AA%E5%9C%9620160312152041.jpg" alt=""></p>
<p>代码也很简单.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rq=root(q);</span><br><span class="line">        <span class="keyword">int</span> rp=root(p);</span><br><span class="line">        <span class="keyword">if</span>(size[rp]&gt;=size[rq])&#123;</span><br><span class="line">            data[rq]=rp;</span><br><span class="line">            size[rp]+=size[rq];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            data[rp]=rq;</span><br><span class="line">            size[rq]+=size[rp];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时复杂度为<code>logN</code></p>
<h3 id="path-compression"><a href="#path-compression" class="headerlink" title="path compression"></a>path compression</h3><p>另一种方法路径压缩。因为我们在使用并查集的时候并不关心数据顺序。所以可以在查询根节点时候，顺便压缩树的高度。</p>
<p>具体措施就是 把<code>index=1</code>的父节点<code>data[index]</code>挂接到他的祖父节点上也就是<code>data[data[index]]</code></p>
<p>一行代码，就搞定。时间复杂度也为<code>logN</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">root</span><span class="params">(<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(data[r]!=r)&#123;</span><br><span class="line">        data[r]=data[data[r]]</span><br><span class="line">        r=data[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="效率比较"><a href="#效率比较" class="headerlink" title="效率比较"></a>效率比较</h2><p><img src="http://7xrsib.com1.z0.glb.clouddn.com/union-findQQ%E6%88%AA%E5%9C%9620160312152827.jpg" alt=""></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.coursera.org/course/algs4partI" target="_blank" rel="external">Algorithms</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/02/Java static 初始化顺序/" itemprop="url">
                  Java static 初始化顺序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-03-02T15:13:06+08:00" content="2016-03-02">
              2016-03-02
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在之前用<code>java</code>的时候，总是对<code>static</code>的初始化顺序存有疑惑，今天在重撸<code>Thinking in Java</code>,一下子豁然开朗，特此做下笔记。</p>
<h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><p>类内，总是先初始化字段，字段定义的先后顺序决定了初始化的顺序，然后再初始化构造器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// When the constructor is called to create a</span></span><br><span class="line"><span class="comment">// Window object, you'll see a message:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span> </span>&#123;</span><br><span class="line">  Window(<span class="keyword">int</span> marker) &#123; print(<span class="string">"Window("</span> + marker + <span class="string">")"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">  Window w1 = <span class="keyword">new</span> Window(<span class="number">1</span>); <span class="comment">// Before constructor</span></span><br><span class="line">  House() &#123;</span><br><span class="line">    <span class="comment">// Show that we're in the constructor:</span></span><br><span class="line">    print(<span class="string">"House()"</span>);</span><br><span class="line">    w3 = <span class="keyword">new</span> Window(<span class="number">33</span>); <span class="comment">// Reinitialize w3</span></span><br><span class="line">  &#125;</span><br><span class="line">  Window w2 = <span class="keyword">new</span> Window(<span class="number">2</span>); <span class="comment">// After constructor</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; print(<span class="string">"f()"</span>); &#125;</span><br><span class="line">  Window w3 = <span class="keyword">new</span> Window(<span class="number">3</span>); <span class="comment">// At end</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderOfInitialization</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    House h = <span class="keyword">new</span> House();</span><br><span class="line">    h.f(); <span class="comment">// Shows that construction is done</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* Output:</span><br><span class="line">Window(1)</span><br><span class="line">Window(2)</span><br><span class="line">Window(3)</span><br><span class="line">House()</span><br><span class="line">Window(33)</span><br><span class="line">f()</span><br><span class="line">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure></p>
<h2 id="static数据的初始化"><a href="#static数据的初始化" class="headerlink" title="static数据的初始化"></a><code>static</code>数据的初始化</h2><p>加上<code>static</code>限定的字段，是所谓的类字段，也就是说这个字段的拥有者不是对象而是类。无论创建多少对象，<code>static</code>数据都只有一份。</p>
<p>类内总是先初始化<code>static</code>字段，再初始化一般字段。接着初始化构造器。但是如果不创建这个类的对象，那这个对象是不会进行初始化的，并且只执行一次。</p>
<p>如下面的代码，在<code>StaticInitialization</code>类中，先初始化<code>static Table table = new Table();</code>，然后才去初始化<code>Table</code>对象，不然是不会被初始化的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bowl</span> </span>&#123;</span><br><span class="line">  Bowl(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">    print(<span class="string">"Bowl("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">"f1("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Table</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Bowl bowl1 = <span class="keyword">new</span> Bowl(<span class="number">1</span>);</span><br><span class="line">  Table() &#123;</span><br><span class="line">    print(<span class="string">"Table()"</span>);</span><br><span class="line">    bowl2.f1(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">"f2("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Bowl bowl2 = <span class="keyword">new</span> Bowl(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cupboard</span> </span>&#123;</span><br><span class="line">  Bowl bowl3 = <span class="keyword">new</span> Bowl(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">static</span> Bowl bowl4 = <span class="keyword">new</span> Bowl(<span class="number">4</span>);</span><br><span class="line">  Cupboard() &#123;</span><br><span class="line">    print(<span class="string">"Cupboard()"</span>);</span><br><span class="line">    bowl4.f1(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">"f3("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Bowl bowl5 = <span class="keyword">new</span> Bowl(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInitialization</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">"Creating new Cupboard() in main"</span>);</span><br><span class="line">    <span class="keyword">new</span> Cupboard();</span><br><span class="line">    print(<span class="string">"Creating new Cupboard() in main"</span>);</span><br><span class="line">    <span class="keyword">new</span> Cupboard();</span><br><span class="line">    table.f2(<span class="number">1</span>);</span><br><span class="line">    cupboard.f3(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Table table = <span class="keyword">new</span> Table();</span><br><span class="line">  <span class="keyword">static</span> Cupboard cupboard = <span class="keyword">new</span> Cupboard();</span><br><span class="line">&#125; <span class="comment">/* Output:</span><br><span class="line">Bowl(1)</span><br><span class="line">Bowl(2)</span><br><span class="line">Table()</span><br><span class="line">f1(1)</span><br><span class="line">Bowl(4)</span><br><span class="line">Bowl(5)</span><br><span class="line">Bowl(3)</span><br><span class="line">Cupboard()</span><br><span class="line">f1(2)</span><br><span class="line">Creating new Cupboard() in main</span><br><span class="line">Bowl(3)</span><br><span class="line">Cupboard()</span><br><span class="line">f1(2)</span><br><span class="line">Creating new Cupboard() in main</span><br><span class="line">Bowl(3)</span><br><span class="line">Cupboard()</span><br><span class="line">f1(2)</span><br><span class="line">f2(1)</span><br><span class="line">f3(1)</span><br><span class="line">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure></p>
<h2 id="显示的静态初始化（也就是静态块）"><a href="#显示的静态初始化（也就是静态块）" class="headerlink" title="显示的静态初始化（也就是静态块）"></a>显示的静态初始化（也就是静态块）</h2><p>把多个初始化语句包在一个<code>static</code>花括号里，叫做<strong>静态块</strong>，其实就是把多个static合在一起写了，本质是一样的。只有首次创建对象或者首次访问类的字段时才会执行，而且仅仅一次。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cup</span> </span>&#123;</span><br><span class="line">  Cup(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">    print(<span class="string">"Cup("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">"f("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cups</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Cup cup1;</span><br><span class="line">  <span class="keyword">static</span> Cup cup2;</span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    cup1 = <span class="keyword">new</span> Cup(<span class="number">1</span>);</span><br><span class="line">    cup2 = <span class="keyword">new</span> Cup(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Cups() &#123;</span><br><span class="line">    print(<span class="string">"Cups()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitStatic</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">"Inside main()"</span>);</span><br><span class="line">    Cups.cup1.f(<span class="number">99</span>);  <span class="comment">// (1)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// static Cups cups1 = new Cups();  // (2)</span></span><br><span class="line">  <span class="comment">// static Cups cups2 = new Cups();  // (2)</span></span><br><span class="line">&#125; <span class="comment">/* Output:</span><br><span class="line">Inside main()</span><br><span class="line">Cup(1)</span><br><span class="line">Cup(2)</span><br><span class="line">f(99)</span><br><span class="line">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure></p>
<h2 id="非静态实例初始化"><a href="#非静态实例初始化" class="headerlink" title="非静态实例初始化"></a>非静态实例初始化</h2><p>这个没什么好讲的，就是普通初始化，按顺序执行，可以多次执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mug</span> </span>&#123;</span><br><span class="line">  Mug(<span class="keyword">int</span> marker) &#123;</span><br><span class="line">    print(<span class="string">"Mug("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> marker)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">"f("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mugs</span> </span>&#123;</span><br><span class="line">  Mug mug1;</span><br><span class="line">  Mug mug2;</span><br><span class="line">  &#123;</span><br><span class="line">    mug1 = <span class="keyword">new</span> Mug(<span class="number">1</span>);</span><br><span class="line">    mug2 = <span class="keyword">new</span> Mug(<span class="number">2</span>);</span><br><span class="line">    print(<span class="string">"mug1 &amp; mug2 initialized"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Mugs() &#123;</span><br><span class="line">    print(<span class="string">"Mugs()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Mugs(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    print(<span class="string">"Mugs(int)"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    print(<span class="string">"Inside main()"</span>);</span><br><span class="line">    <span class="keyword">new</span> Mugs();</span><br><span class="line">    print(<span class="string">"new Mugs() completed"</span>);</span><br><span class="line">    <span class="keyword">new</span> Mugs(<span class="number">1</span>);</span><br><span class="line">    print(<span class="string">"new Mugs(1) completed"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span><br><span class="line">Inside main()</span><br><span class="line">Mug(1)</span><br><span class="line">Mug(2)</span><br><span class="line">mug1 &amp; mug2 initialized</span><br><span class="line">Mugs()</span><br><span class="line">new Mugs() completed</span><br><span class="line">Mug(1)</span><br><span class="line">Mug(2)</span><br><span class="line">mug1 &amp; mug2 initialized</span><br><span class="line">Mugs(int)</span><br><span class="line">new Mugs(1) completed</span><br><span class="line">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>实例代码均来自《Thinking in Java》</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Threezj" />
          <p class="site-author-name" itemprop="name">Threezj</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">Tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Threezj</span>
</div>

<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  
  

  

  

</body>
</html>
